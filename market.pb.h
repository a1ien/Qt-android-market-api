// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: market.proto

#ifndef PROTOBUF_market_2eproto__INCLUDED
#define PROTOBUF_market_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_market_2eproto();
void protobuf_AssignDesc_market_2eproto();
void protobuf_ShutdownFile_market_2eproto();

class AppsRequest;
class AppsResponse;
class Category;
class CommentsRequest;
class CommentsResponse;
class App;
class App_ExtendedInfo;
class Comment;
class CategoriesRequest;
class CategoriesResponse;
class SubCategoriesRequest;
class SubCategoriesResponse;
class RequestContext;
class GetImageRequest;
class GetAssetRequest;
class GetImageResponse;
class GetAssetResponse;
class GetAssetResponse_InstallAsset;
class Request;
class Request_RequestGroup;
class ResponseContext;
class Response;
class Response_ResponseGroup;

enum AppsRequest_OrderType {
  AppsRequest_OrderType_NONE = 0,
  AppsRequest_OrderType_POPULAR = 1,
  AppsRequest_OrderType_NEWEST = 2,
  AppsRequest_OrderType_FEATURED = 3
};
bool AppsRequest_OrderType_IsValid(int value);
const AppsRequest_OrderType AppsRequest_OrderType_OrderType_MIN = AppsRequest_OrderType_NONE;
const AppsRequest_OrderType AppsRequest_OrderType_OrderType_MAX = AppsRequest_OrderType_FEATURED;
const int AppsRequest_OrderType_OrderType_ARRAYSIZE = AppsRequest_OrderType_OrderType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AppsRequest_OrderType_descriptor();
inline const ::std::string& AppsRequest_OrderType_Name(AppsRequest_OrderType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AppsRequest_OrderType_descriptor(), value);
}
inline bool AppsRequest_OrderType_Parse(
    const ::std::string& name, AppsRequest_OrderType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AppsRequest_OrderType>(
    AppsRequest_OrderType_descriptor(), name, value);
}
enum AppsRequest_ViewType {
  AppsRequest_ViewType_ALL = 0,
  AppsRequest_ViewType_FREE = 1,
  AppsRequest_ViewType_PAID = 2
};
bool AppsRequest_ViewType_IsValid(int value);
const AppsRequest_ViewType AppsRequest_ViewType_ViewType_MIN = AppsRequest_ViewType_ALL;
const AppsRequest_ViewType AppsRequest_ViewType_ViewType_MAX = AppsRequest_ViewType_PAID;
const int AppsRequest_ViewType_ViewType_ARRAYSIZE = AppsRequest_ViewType_ViewType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AppsRequest_ViewType_descriptor();
inline const ::std::string& AppsRequest_ViewType_Name(AppsRequest_ViewType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AppsRequest_ViewType_descriptor(), value);
}
inline bool AppsRequest_ViewType_Parse(
    const ::std::string& name, AppsRequest_ViewType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AppsRequest_ViewType>(
    AppsRequest_ViewType_descriptor(), name, value);
}
enum GetImageRequest_AppImageUsage {
  GetImageRequest_AppImageUsage_ICON = 0,
  GetImageRequest_AppImageUsage_SCREENSHOT = 1,
  GetImageRequest_AppImageUsage_SCREENSHOT_THUMBNAIL = 2,
  GetImageRequest_AppImageUsage_PROMO_BADGE = 3,
  GetImageRequest_AppImageUsage_BILING_ICON = 4
};
bool GetImageRequest_AppImageUsage_IsValid(int value);
const GetImageRequest_AppImageUsage GetImageRequest_AppImageUsage_AppImageUsage_MIN = GetImageRequest_AppImageUsage_ICON;
const GetImageRequest_AppImageUsage GetImageRequest_AppImageUsage_AppImageUsage_MAX = GetImageRequest_AppImageUsage_BILING_ICON;
const int GetImageRequest_AppImageUsage_AppImageUsage_ARRAYSIZE = GetImageRequest_AppImageUsage_AppImageUsage_MAX + 1;

const ::google::protobuf::EnumDescriptor* GetImageRequest_AppImageUsage_descriptor();
inline const ::std::string& GetImageRequest_AppImageUsage_Name(GetImageRequest_AppImageUsage value) {
  return ::google::protobuf::internal::NameOfEnum(
    GetImageRequest_AppImageUsage_descriptor(), value);
}
inline bool GetImageRequest_AppImageUsage_Parse(
    const ::std::string& name, GetImageRequest_AppImageUsage* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GetImageRequest_AppImageUsage>(
    GetImageRequest_AppImageUsage_descriptor(), name, value);
}
enum ResponseContext_ResultType {
  ResponseContext_ResultType_OK = 0,
  ResponseContext_ResultType_BAD_REQUEST = 1,
  ResponseContext_ResultType_INTERNAL_SERVICE_ERROR = 2,
  ResponseContext_ResultType_NOT_MODIFIED = 3,
  ResponseContext_ResultType_USER_INPUT_ERROR = 4
};
bool ResponseContext_ResultType_IsValid(int value);
const ResponseContext_ResultType ResponseContext_ResultType_ResultType_MIN = ResponseContext_ResultType_OK;
const ResponseContext_ResultType ResponseContext_ResultType_ResultType_MAX = ResponseContext_ResultType_USER_INPUT_ERROR;
const int ResponseContext_ResultType_ResultType_ARRAYSIZE = ResponseContext_ResultType_ResultType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResponseContext_ResultType_descriptor();
inline const ::std::string& ResponseContext_ResultType_Name(ResponseContext_ResultType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResponseContext_ResultType_descriptor(), value);
}
inline bool ResponseContext_ResultType_Parse(
    const ::std::string& name, ResponseContext_ResultType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResponseContext_ResultType>(
    ResponseContext_ResultType_descriptor(), name, value);
}
enum AppType {
  NONE = 0,
  APPLICATION = 1,
  RINGTONE = 2,
  WALLPAPER = 3,
  GAME = 4
};
bool AppType_IsValid(int value);
const AppType AppType_MIN = NONE;
const AppType AppType_MAX = GAME;
const int AppType_ARRAYSIZE = AppType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AppType_descriptor();
inline const ::std::string& AppType_Name(AppType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AppType_descriptor(), value);
}
inline bool AppType_Parse(
    const ::std::string& name, AppType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AppType>(
    AppType_descriptor(), name, value);
}
// ===================================================================

class AppsRequest : public ::google::protobuf::Message {
 public:
  AppsRequest();
  virtual ~AppsRequest();
  
  AppsRequest(const AppsRequest& from);
  
  inline AppsRequest& operator=(const AppsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AppsRequest& default_instance();
  
  void Swap(AppsRequest* other);
  
  // implements Message ----------------------------------------------
  
  AppsRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AppsRequest& from);
  void MergeFrom(const AppsRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef AppsRequest_OrderType OrderType;
  static const OrderType NONE = AppsRequest_OrderType_NONE;
  static const OrderType POPULAR = AppsRequest_OrderType_POPULAR;
  static const OrderType NEWEST = AppsRequest_OrderType_NEWEST;
  static const OrderType FEATURED = AppsRequest_OrderType_FEATURED;
  static inline bool OrderType_IsValid(int value) {
    return AppsRequest_OrderType_IsValid(value);
  }
  static const OrderType OrderType_MIN =
    AppsRequest_OrderType_OrderType_MIN;
  static const OrderType OrderType_MAX =
    AppsRequest_OrderType_OrderType_MAX;
  static const int OrderType_ARRAYSIZE =
    AppsRequest_OrderType_OrderType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OrderType_descriptor() {
    return AppsRequest_OrderType_descriptor();
  }
  static inline const ::std::string& OrderType_Name(OrderType value) {
    return AppsRequest_OrderType_Name(value);
  }
  static inline bool OrderType_Parse(const ::std::string& name,
      OrderType* value) {
    return AppsRequest_OrderType_Parse(name, value);
  }
  
  typedef AppsRequest_ViewType ViewType;
  static const ViewType ALL = AppsRequest_ViewType_ALL;
  static const ViewType FREE = AppsRequest_ViewType_FREE;
  static const ViewType PAID = AppsRequest_ViewType_PAID;
  static inline bool ViewType_IsValid(int value) {
    return AppsRequest_ViewType_IsValid(value);
  }
  static const ViewType ViewType_MIN =
    AppsRequest_ViewType_ViewType_MIN;
  static const ViewType ViewType_MAX =
    AppsRequest_ViewType_ViewType_MAX;
  static const int ViewType_ARRAYSIZE =
    AppsRequest_ViewType_ViewType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ViewType_descriptor() {
    return AppsRequest_ViewType_descriptor();
  }
  static inline const ::std::string& ViewType_Name(ViewType value) {
    return AppsRequest_ViewType_Name(value);
  }
  static inline bool ViewType_Parse(const ::std::string& name,
      ViewType* value) {
    return AppsRequest_ViewType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional .AppType appType = 1;
  inline bool has_apptype() const;
  inline void clear_apptype();
  static const int kAppTypeFieldNumber = 1;
  inline AppType apptype() const;
  inline void set_apptype(AppType value);
  
  // optional string query = 2;
  inline bool has_query() const;
  inline void clear_query();
  static const int kQueryFieldNumber = 2;
  inline const ::std::string& query() const;
  inline void set_query(const ::std::string& value);
  inline void set_query(const char* value);
  inline void set_query(const char* value, size_t size);
  inline ::std::string* mutable_query();
  inline ::std::string* release_query();
  
  // optional string categoryId = 3;
  inline bool has_categoryid() const;
  inline void clear_categoryid();
  static const int kCategoryIdFieldNumber = 3;
  inline const ::std::string& categoryid() const;
  inline void set_categoryid(const ::std::string& value);
  inline void set_categoryid(const char* value);
  inline void set_categoryid(const char* value, size_t size);
  inline ::std::string* mutable_categoryid();
  inline ::std::string* release_categoryid();
  
  // optional string appId = 4;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIdFieldNumber = 4;
  inline const ::std::string& appid() const;
  inline void set_appid(const ::std::string& value);
  inline void set_appid(const char* value);
  inline void set_appid(const char* value, size_t size);
  inline ::std::string* mutable_appid();
  inline ::std::string* release_appid();
  
  // optional bool withExtendedInfo = 6;
  inline bool has_withextendedinfo() const;
  inline void clear_withextendedinfo();
  static const int kWithExtendedInfoFieldNumber = 6;
  inline bool withextendedinfo() const;
  inline void set_withextendedinfo(bool value);
  
  // optional .AppsRequest.OrderType orderType = 7 [default = NONE];
  inline bool has_ordertype() const;
  inline void clear_ordertype();
  static const int kOrderTypeFieldNumber = 7;
  inline ::AppsRequest_OrderType ordertype() const;
  inline void set_ordertype(::AppsRequest_OrderType value);
  
  // optional uint64 startIndex = 8;
  inline bool has_startindex() const;
  inline void clear_startindex();
  static const int kStartIndexFieldNumber = 8;
  inline ::google::protobuf::uint64 startindex() const;
  inline void set_startindex(::google::protobuf::uint64 value);
  
  // optional int32 entriesCount = 9;
  inline bool has_entriescount() const;
  inline void clear_entriescount();
  static const int kEntriesCountFieldNumber = 9;
  inline ::google::protobuf::int32 entriescount() const;
  inline void set_entriescount(::google::protobuf::int32 value);
  
  // optional .AppsRequest.ViewType viewType = 10 [default = ALL];
  inline bool has_viewtype() const;
  inline void clear_viewtype();
  static const int kViewTypeFieldNumber = 10;
  inline ::AppsRequest_ViewType viewtype() const;
  inline void set_viewtype(::AppsRequest_ViewType value);
  
  // @@protoc_insertion_point(class_scope:AppsRequest)
 private:
  inline void set_has_apptype();
  inline void clear_has_apptype();
  inline void set_has_query();
  inline void clear_has_query();
  inline void set_has_categoryid();
  inline void clear_has_categoryid();
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_withextendedinfo();
  inline void clear_has_withextendedinfo();
  inline void set_has_ordertype();
  inline void clear_has_ordertype();
  inline void set_has_startindex();
  inline void clear_has_startindex();
  inline void set_has_entriescount();
  inline void clear_has_entriescount();
  inline void set_has_viewtype();
  inline void clear_has_viewtype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* query_;
  ::std::string* categoryid_;
  int apptype_;
  bool withextendedinfo_;
  ::std::string* appid_;
  ::google::protobuf::uint64 startindex_;
  int ordertype_;
  ::google::protobuf::int32 entriescount_;
  int viewtype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_market_2eproto();
  friend void protobuf_AssignDesc_market_2eproto();
  friend void protobuf_ShutdownFile_market_2eproto();
  
  void InitAsDefaultInstance();
  static AppsRequest* default_instance_;
};
// -------------------------------------------------------------------

class AppsResponse : public ::google::protobuf::Message {
 public:
  AppsResponse();
  virtual ~AppsResponse();
  
  AppsResponse(const AppsResponse& from);
  
  inline AppsResponse& operator=(const AppsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AppsResponse& default_instance();
  
  void Swap(AppsResponse* other);
  
  // implements Message ----------------------------------------------
  
  AppsResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AppsResponse& from);
  void MergeFrom(const AppsResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .App app = 1;
  inline int app_size() const;
  inline void clear_app();
  static const int kAppFieldNumber = 1;
  inline const ::App& app(int index) const;
  inline ::App* mutable_app(int index);
  inline ::App* add_app();
  inline const ::google::protobuf::RepeatedPtrField< ::App >&
      app() const;
  inline ::google::protobuf::RepeatedPtrField< ::App >*
      mutable_app();
  
  // optional int32 entriesCount = 2;
  inline bool has_entriescount() const;
  inline void clear_entriescount();
  static const int kEntriesCountFieldNumber = 2;
  inline ::google::protobuf::int32 entriescount() const;
  inline void set_entriescount(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:AppsResponse)
 private:
  inline void set_has_entriescount();
  inline void clear_has_entriescount();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::App > app_;
  ::google::protobuf::int32 entriescount_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_market_2eproto();
  friend void protobuf_AssignDesc_market_2eproto();
  friend void protobuf_ShutdownFile_market_2eproto();
  
  void InitAsDefaultInstance();
  static AppsResponse* default_instance_;
};
// -------------------------------------------------------------------

class Category : public ::google::protobuf::Message {
 public:
  Category();
  virtual ~Category();
  
  Category(const Category& from);
  
  inline Category& operator=(const Category& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Category& default_instance();
  
  void Swap(Category* other);
  
  // implements Message ----------------------------------------------
  
  Category* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Category& from);
  void MergeFrom(const Category& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 appType = 2;
  inline bool has_apptype() const;
  inline void clear_apptype();
  static const int kAppTypeFieldNumber = 2;
  inline ::google::protobuf::int32 apptype() const;
  inline void set_apptype(::google::protobuf::int32 value);
  
  // optional string title = 4;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 4;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  
  // optional string categoryId = 3;
  inline bool has_categoryid() const;
  inline void clear_categoryid();
  static const int kCategoryIdFieldNumber = 3;
  inline const ::std::string& categoryid() const;
  inline void set_categoryid(const ::std::string& value);
  inline void set_categoryid(const char* value);
  inline void set_categoryid(const char* value, size_t size);
  inline ::std::string* mutable_categoryid();
  inline ::std::string* release_categoryid();
  
  // optional string subtitle = 5;
  inline bool has_subtitle() const;
  inline void clear_subtitle();
  static const int kSubtitleFieldNumber = 5;
  inline const ::std::string& subtitle() const;
  inline void set_subtitle(const ::std::string& value);
  inline void set_subtitle(const char* value);
  inline void set_subtitle(const char* value, size_t size);
  inline ::std::string* mutable_subtitle();
  inline ::std::string* release_subtitle();
  
  // repeated .Category subCategories = 8;
  inline int subcategories_size() const;
  inline void clear_subcategories();
  static const int kSubCategoriesFieldNumber = 8;
  inline const ::Category& subcategories(int index) const;
  inline ::Category* mutable_subcategories(int index);
  inline ::Category* add_subcategories();
  inline const ::google::protobuf::RepeatedPtrField< ::Category >&
      subcategories() const;
  inline ::google::protobuf::RepeatedPtrField< ::Category >*
      mutable_subcategories();
  
  // @@protoc_insertion_point(class_scope:Category)
 private:
  inline void set_has_apptype();
  inline void clear_has_apptype();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_categoryid();
  inline void clear_has_categoryid();
  inline void set_has_subtitle();
  inline void clear_has_subtitle();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* title_;
  ::std::string* categoryid_;
  ::std::string* subtitle_;
  ::google::protobuf::RepeatedPtrField< ::Category > subcategories_;
  ::google::protobuf::int32 apptype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_market_2eproto();
  friend void protobuf_AssignDesc_market_2eproto();
  friend void protobuf_ShutdownFile_market_2eproto();
  
  void InitAsDefaultInstance();
  static Category* default_instance_;
};
// -------------------------------------------------------------------

class CommentsRequest : public ::google::protobuf::Message {
 public:
  CommentsRequest();
  virtual ~CommentsRequest();
  
  CommentsRequest(const CommentsRequest& from);
  
  inline CommentsRequest& operator=(const CommentsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CommentsRequest& default_instance();
  
  void Swap(CommentsRequest* other);
  
  // implements Message ----------------------------------------------
  
  CommentsRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommentsRequest& from);
  void MergeFrom(const CommentsRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string appId = 1;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIdFieldNumber = 1;
  inline const ::std::string& appid() const;
  inline void set_appid(const ::std::string& value);
  inline void set_appid(const char* value);
  inline void set_appid(const char* value, size_t size);
  inline ::std::string* mutable_appid();
  inline ::std::string* release_appid();
  
  // optional int32 startIndex = 2;
  inline bool has_startindex() const;
  inline void clear_startindex();
  static const int kStartIndexFieldNumber = 2;
  inline ::google::protobuf::int32 startindex() const;
  inline void set_startindex(::google::protobuf::int32 value);
  
  // optional int32 entriesCount = 3;
  inline bool has_entriescount() const;
  inline void clear_entriescount();
  static const int kEntriesCountFieldNumber = 3;
  inline ::google::protobuf::int32 entriescount() const;
  inline void set_entriescount(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:CommentsRequest)
 private:
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_startindex();
  inline void clear_has_startindex();
  inline void set_has_entriescount();
  inline void clear_has_entriescount();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* appid_;
  ::google::protobuf::int32 startindex_;
  ::google::protobuf::int32 entriescount_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_market_2eproto();
  friend void protobuf_AssignDesc_market_2eproto();
  friend void protobuf_ShutdownFile_market_2eproto();
  
  void InitAsDefaultInstance();
  static CommentsRequest* default_instance_;
};
// -------------------------------------------------------------------

class CommentsResponse : public ::google::protobuf::Message {
 public:
  CommentsResponse();
  virtual ~CommentsResponse();
  
  CommentsResponse(const CommentsResponse& from);
  
  inline CommentsResponse& operator=(const CommentsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CommentsResponse& default_instance();
  
  void Swap(CommentsResponse* other);
  
  // implements Message ----------------------------------------------
  
  CommentsResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommentsResponse& from);
  void MergeFrom(const CommentsResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .Comment comments = 1;
  inline int comments_size() const;
  inline void clear_comments();
  static const int kCommentsFieldNumber = 1;
  inline const ::Comment& comments(int index) const;
  inline ::Comment* mutable_comments(int index);
  inline ::Comment* add_comments();
  inline const ::google::protobuf::RepeatedPtrField< ::Comment >&
      comments() const;
  inline ::google::protobuf::RepeatedPtrField< ::Comment >*
      mutable_comments();
  
  // optional int32 entriesCount = 2;
  inline bool has_entriescount() const;
  inline void clear_entriescount();
  static const int kEntriesCountFieldNumber = 2;
  inline ::google::protobuf::int32 entriescount() const;
  inline void set_entriescount(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:CommentsResponse)
 private:
  inline void set_has_entriescount();
  inline void clear_has_entriescount();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::Comment > comments_;
  ::google::protobuf::int32 entriescount_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_market_2eproto();
  friend void protobuf_AssignDesc_market_2eproto();
  friend void protobuf_ShutdownFile_market_2eproto();
  
  void InitAsDefaultInstance();
  static CommentsResponse* default_instance_;
};
// -------------------------------------------------------------------

class App_ExtendedInfo : public ::google::protobuf::Message {
 public:
  App_ExtendedInfo();
  virtual ~App_ExtendedInfo();
  
  App_ExtendedInfo(const App_ExtendedInfo& from);
  
  inline App_ExtendedInfo& operator=(const App_ExtendedInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const App_ExtendedInfo& default_instance();
  
  void Swap(App_ExtendedInfo* other);
  
  // implements Message ----------------------------------------------
  
  App_ExtendedInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const App_ExtendedInfo& from);
  void MergeFrom(const App_ExtendedInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string description = 13;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 13;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  
  // optional int32 downloadsCount = 14;
  inline bool has_downloadscount() const;
  inline void clear_downloadscount();
  static const int kDownloadsCountFieldNumber = 14;
  inline ::google::protobuf::int32 downloadscount() const;
  inline void set_downloadscount(::google::protobuf::int32 value);
  
  // repeated string permissionId = 15;
  inline int permissionid_size() const;
  inline void clear_permissionid();
  static const int kPermissionIdFieldNumber = 15;
  inline const ::std::string& permissionid(int index) const;
  inline ::std::string* mutable_permissionid(int index);
  inline void set_permissionid(int index, const ::std::string& value);
  inline void set_permissionid(int index, const char* value);
  inline void set_permissionid(int index, const char* value, size_t size);
  inline ::std::string* add_permissionid();
  inline void add_permissionid(const ::std::string& value);
  inline void add_permissionid(const char* value);
  inline void add_permissionid(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& permissionid() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_permissionid();
  
  // optional int32 installSize = 16;
  inline bool has_installsize() const;
  inline void clear_installsize();
  static const int kInstallSizeFieldNumber = 16;
  inline ::google::protobuf::int32 installsize() const;
  inline void set_installsize(::google::protobuf::int32 value);
  
  // optional string packageName = 17;
  inline bool has_packagename() const;
  inline void clear_packagename();
  static const int kPackageNameFieldNumber = 17;
  inline const ::std::string& packagename() const;
  inline void set_packagename(const ::std::string& value);
  inline void set_packagename(const char* value);
  inline void set_packagename(const char* value, size_t size);
  inline ::std::string* mutable_packagename();
  inline ::std::string* release_packagename();
  
  // optional string category = 18;
  inline bool has_category() const;
  inline void clear_category();
  static const int kCategoryFieldNumber = 18;
  inline const ::std::string& category() const;
  inline void set_category(const ::std::string& value);
  inline void set_category(const char* value);
  inline void set_category(const char* value, size_t size);
  inline ::std::string* mutable_category();
  inline ::std::string* release_category();
  
  // optional string contactEmail = 20;
  inline bool has_contactemail() const;
  inline void clear_contactemail();
  static const int kContactEmailFieldNumber = 20;
  inline const ::std::string& contactemail() const;
  inline void set_contactemail(const ::std::string& value);
  inline void set_contactemail(const char* value);
  inline void set_contactemail(const char* value, size_t size);
  inline ::std::string* mutable_contactemail();
  inline ::std::string* release_contactemail();
  
  // optional string downloadsCountText = 23;
  inline bool has_downloadscounttext() const;
  inline void clear_downloadscounttext();
  static const int kDownloadsCountTextFieldNumber = 23;
  inline const ::std::string& downloadscounttext() const;
  inline void set_downloadscounttext(const ::std::string& value);
  inline void set_downloadscounttext(const char* value);
  inline void set_downloadscounttext(const char* value, size_t size);
  inline ::std::string* mutable_downloadscounttext();
  inline ::std::string* release_downloadscounttext();
  
  // optional string contactPhone = 26;
  inline bool has_contactphone() const;
  inline void clear_contactphone();
  static const int kContactPhoneFieldNumber = 26;
  inline const ::std::string& contactphone() const;
  inline void set_contactphone(const ::std::string& value);
  inline void set_contactphone(const char* value);
  inline void set_contactphone(const char* value, size_t size);
  inline ::std::string* mutable_contactphone();
  inline ::std::string* release_contactphone();
  
  // optional string contactWebsite = 27;
  inline bool has_contactwebsite() const;
  inline void clear_contactwebsite();
  static const int kContactWebsiteFieldNumber = 27;
  inline const ::std::string& contactwebsite() const;
  inline void set_contactwebsite(const ::std::string& value);
  inline void set_contactwebsite(const char* value);
  inline void set_contactwebsite(const char* value, size_t size);
  inline ::std::string* mutable_contactwebsite();
  inline ::std::string* release_contactwebsite();
  
  // optional int32 screenshotsCount = 30;
  inline bool has_screenshotscount() const;
  inline void clear_screenshotscount();
  static const int kScreenshotsCountFieldNumber = 30;
  inline ::google::protobuf::int32 screenshotscount() const;
  inline void set_screenshotscount(::google::protobuf::int32 value);
  
  // optional string promoText = 31;
  inline bool has_promotext() const;
  inline void clear_promotext();
  static const int kPromoTextFieldNumber = 31;
  inline const ::std::string& promotext() const;
  inline void set_promotext(const ::std::string& value);
  inline void set_promotext(const char* value);
  inline void set_promotext(const char* value, size_t size);
  inline ::std::string* mutable_promotext();
  inline ::std::string* release_promotext();
  
  // optional string recentChanges = 38;
  inline bool has_recentchanges() const;
  inline void clear_recentchanges();
  static const int kRecentChangesFieldNumber = 38;
  inline const ::std::string& recentchanges() const;
  inline void set_recentchanges(const ::std::string& value);
  inline void set_recentchanges(const char* value);
  inline void set_recentchanges(const char* value, size_t size);
  inline ::std::string* mutable_recentchanges();
  inline ::std::string* release_recentchanges();
  
  // optional string promotionalVideo = 43;
  inline bool has_promotionalvideo() const;
  inline void clear_promotionalvideo();
  static const int kPromotionalVideoFieldNumber = 43;
  inline const ::std::string& promotionalvideo() const;
  inline void set_promotionalvideo(const ::std::string& value);
  inline void set_promotionalvideo(const char* value);
  inline void set_promotionalvideo(const char* value, size_t size);
  inline ::std::string* mutable_promotionalvideo();
  inline ::std::string* release_promotionalvideo();
  
  // @@protoc_insertion_point(class_scope:App.ExtendedInfo)
 private:
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_downloadscount();
  inline void clear_has_downloadscount();
  inline void set_has_installsize();
  inline void clear_has_installsize();
  inline void set_has_packagename();
  inline void clear_has_packagename();
  inline void set_has_category();
  inline void clear_has_category();
  inline void set_has_contactemail();
  inline void clear_has_contactemail();
  inline void set_has_downloadscounttext();
  inline void clear_has_downloadscounttext();
  inline void set_has_contactphone();
  inline void clear_has_contactphone();
  inline void set_has_contactwebsite();
  inline void clear_has_contactwebsite();
  inline void set_has_screenshotscount();
  inline void clear_has_screenshotscount();
  inline void set_has_promotext();
  inline void clear_has_promotext();
  inline void set_has_recentchanges();
  inline void clear_has_recentchanges();
  inline void set_has_promotionalvideo();
  inline void clear_has_promotionalvideo();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* description_;
  ::google::protobuf::RepeatedPtrField< ::std::string> permissionid_;
  ::google::protobuf::int32 downloadscount_;
  ::google::protobuf::int32 installsize_;
  ::std::string* packagename_;
  ::std::string* category_;
  ::std::string* contactemail_;
  ::std::string* downloadscounttext_;
  ::std::string* contactphone_;
  ::std::string* contactwebsite_;
  ::std::string* promotext_;
  ::std::string* recentchanges_;
  ::std::string* promotionalvideo_;
  ::google::protobuf::int32 screenshotscount_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];
  
  friend void  protobuf_AddDesc_market_2eproto();
  friend void protobuf_AssignDesc_market_2eproto();
  friend void protobuf_ShutdownFile_market_2eproto();
  
  void InitAsDefaultInstance();
  static App_ExtendedInfo* default_instance_;
};
// -------------------------------------------------------------------

class App : public ::google::protobuf::Message {
 public:
  App();
  virtual ~App();
  
  App(const App& from);
  
  inline App& operator=(const App& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const App& default_instance();
  
  void Swap(App* other);
  
  // implements Message ----------------------------------------------
  
  App* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const App& from);
  void MergeFrom(const App& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef App_ExtendedInfo ExtendedInfo;
  
  // accessors -------------------------------------------------------
  
  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // optional string title = 2;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 2;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  
  // optional .AppType appType = 3 [default = NONE];
  inline bool has_apptype() const;
  inline void clear_apptype();
  static const int kAppTypeFieldNumber = 3;
  inline AppType apptype() const;
  inline void set_apptype(AppType value);
  
  // optional string creator = 4;
  inline bool has_creator() const;
  inline void clear_creator();
  static const int kCreatorFieldNumber = 4;
  inline const ::std::string& creator() const;
  inline void set_creator(const ::std::string& value);
  inline void set_creator(const char* value);
  inline void set_creator(const char* value, size_t size);
  inline ::std::string* mutable_creator();
  inline ::std::string* release_creator();
  
  // optional string version = 5;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 5;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // optional string price = 6;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 6;
  inline const ::std::string& price() const;
  inline void set_price(const ::std::string& value);
  inline void set_price(const char* value);
  inline void set_price(const char* value, size_t size);
  inline ::std::string* mutable_price();
  inline ::std::string* release_price();
  
  // optional string rating = 7;
  inline bool has_rating() const;
  inline void clear_rating();
  static const int kRatingFieldNumber = 7;
  inline const ::std::string& rating() const;
  inline void set_rating(const ::std::string& value);
  inline void set_rating(const char* value);
  inline void set_rating(const char* value, size_t size);
  inline ::std::string* mutable_rating();
  inline ::std::string* release_rating();
  
  // optional int32 ratingsCount = 8;
  inline bool has_ratingscount() const;
  inline void clear_ratingscount();
  static const int kRatingsCountFieldNumber = 8;
  inline ::google::protobuf::int32 ratingscount() const;
  inline void set_ratingscount(::google::protobuf::int32 value);
  
  // optional group ExtendedInfo = 12 {
  inline bool has_extendedinfo() const;
  inline void clear_extendedinfo();
  static const int kExtendedinfoFieldNumber = 12;
  inline const ::App_ExtendedInfo& extendedinfo() const;
  inline ::App_ExtendedInfo* mutable_extendedinfo();
  inline ::App_ExtendedInfo* release_extendedinfo();
  
  // optional string creatorId = 22;
  inline bool has_creatorid() const;
  inline void clear_creatorid();
  static const int kCreatorIdFieldNumber = 22;
  inline const ::std::string& creatorid() const;
  inline void set_creatorid(const ::std::string& value);
  inline void set_creatorid(const char* value);
  inline void set_creatorid(const char* value, size_t size);
  inline ::std::string* mutable_creatorid();
  inline ::std::string* release_creatorid();
  
  // optional string packageName = 24;
  inline bool has_packagename() const;
  inline void clear_packagename();
  static const int kPackageNameFieldNumber = 24;
  inline const ::std::string& packagename() const;
  inline void set_packagename(const ::std::string& value);
  inline void set_packagename(const char* value);
  inline void set_packagename(const char* value, size_t size);
  inline ::std::string* mutable_packagename();
  inline ::std::string* release_packagename();
  
  // optional int32 versionCode = 25;
  inline bool has_versioncode() const;
  inline void clear_versioncode();
  static const int kVersionCodeFieldNumber = 25;
  inline ::google::protobuf::int32 versioncode() const;
  inline void set_versioncode(::google::protobuf::int32 value);
  
  // optional string priceCurrency = 32;
  inline bool has_pricecurrency() const;
  inline void clear_pricecurrency();
  static const int kPriceCurrencyFieldNumber = 32;
  inline const ::std::string& pricecurrency() const;
  inline void set_pricecurrency(const ::std::string& value);
  inline void set_pricecurrency(const char* value);
  inline void set_pricecurrency(const char* value, size_t size);
  inline ::std::string* mutable_pricecurrency();
  inline ::std::string* release_pricecurrency();
  
  // optional int32 priceMicros = 33;
  inline bool has_pricemicros() const;
  inline void clear_pricemicros();
  static const int kPriceMicrosFieldNumber = 33;
  inline ::google::protobuf::int32 pricemicros() const;
  inline void set_pricemicros(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:App)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_apptype();
  inline void clear_has_apptype();
  inline void set_has_creator();
  inline void clear_has_creator();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_rating();
  inline void clear_has_rating();
  inline void set_has_ratingscount();
  inline void clear_has_ratingscount();
  inline void set_has_extendedinfo();
  inline void clear_has_extendedinfo();
  inline void set_has_creatorid();
  inline void clear_has_creatorid();
  inline void set_has_packagename();
  inline void clear_has_packagename();
  inline void set_has_versioncode();
  inline void clear_has_versioncode();
  inline void set_has_pricecurrency();
  inline void clear_has_pricecurrency();
  inline void set_has_pricemicros();
  inline void clear_has_pricemicros();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* id_;
  ::std::string* title_;
  ::std::string* creator_;
  ::std::string* version_;
  int apptype_;
  ::google::protobuf::int32 ratingscount_;
  ::std::string* price_;
  ::std::string* rating_;
  ::App_ExtendedInfo* extendedinfo_;
  ::std::string* creatorid_;
  ::std::string* packagename_;
  ::std::string* pricecurrency_;
  ::google::protobuf::int32 versioncode_;
  ::google::protobuf::int32 pricemicros_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];
  
  friend void  protobuf_AddDesc_market_2eproto();
  friend void protobuf_AssignDesc_market_2eproto();
  friend void protobuf_ShutdownFile_market_2eproto();
  
  void InitAsDefaultInstance();
  static App* default_instance_;
};
// -------------------------------------------------------------------

class Comment : public ::google::protobuf::Message {
 public:
  Comment();
  virtual ~Comment();
  
  Comment(const Comment& from);
  
  inline Comment& operator=(const Comment& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Comment& default_instance();
  
  void Swap(Comment* other);
  
  // implements Message ----------------------------------------------
  
  Comment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Comment& from);
  void MergeFrom(const Comment& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string text = 1;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 1;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  
  // optional int32 rating = 2;
  inline bool has_rating() const;
  inline void clear_rating();
  static const int kRatingFieldNumber = 2;
  inline ::google::protobuf::int32 rating() const;
  inline void set_rating(::google::protobuf::int32 value);
  
  // optional string authorName = 3;
  inline bool has_authorname() const;
  inline void clear_authorname();
  static const int kAuthorNameFieldNumber = 3;
  inline const ::std::string& authorname() const;
  inline void set_authorname(const ::std::string& value);
  inline void set_authorname(const char* value);
  inline void set_authorname(const char* value, size_t size);
  inline ::std::string* mutable_authorname();
  inline ::std::string* release_authorname();
  
  // optional uint64 creationTime = 4;
  inline bool has_creationtime() const;
  inline void clear_creationtime();
  static const int kCreationTimeFieldNumber = 4;
  inline ::google::protobuf::uint64 creationtime() const;
  inline void set_creationtime(::google::protobuf::uint64 value);
  
  // optional string authorId = 5;
  inline bool has_authorid() const;
  inline void clear_authorid();
  static const int kAuthorIdFieldNumber = 5;
  inline const ::std::string& authorid() const;
  inline void set_authorid(const ::std::string& value);
  inline void set_authorid(const char* value);
  inline void set_authorid(const char* value, size_t size);
  inline ::std::string* mutable_authorid();
  inline ::std::string* release_authorid();
  
  // @@protoc_insertion_point(class_scope:Comment)
 private:
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_rating();
  inline void clear_has_rating();
  inline void set_has_authorname();
  inline void clear_has_authorname();
  inline void set_has_creationtime();
  inline void clear_has_creationtime();
  inline void set_has_authorid();
  inline void clear_has_authorid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* text_;
  ::std::string* authorname_;
  ::google::protobuf::uint64 creationtime_;
  ::std::string* authorid_;
  ::google::protobuf::int32 rating_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_market_2eproto();
  friend void protobuf_AssignDesc_market_2eproto();
  friend void protobuf_ShutdownFile_market_2eproto();
  
  void InitAsDefaultInstance();
  static Comment* default_instance_;
};
// -------------------------------------------------------------------

class CategoriesRequest : public ::google::protobuf::Message {
 public:
  CategoriesRequest();
  virtual ~CategoriesRequest();
  
  CategoriesRequest(const CategoriesRequest& from);
  
  inline CategoriesRequest& operator=(const CategoriesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CategoriesRequest& default_instance();
  
  void Swap(CategoriesRequest* other);
  
  // implements Message ----------------------------------------------
  
  CategoriesRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CategoriesRequest& from);
  void MergeFrom(const CategoriesRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:CategoriesRequest)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_market_2eproto();
  friend void protobuf_AssignDesc_market_2eproto();
  friend void protobuf_ShutdownFile_market_2eproto();
  
  void InitAsDefaultInstance();
  static CategoriesRequest* default_instance_;
};
// -------------------------------------------------------------------

class CategoriesResponse : public ::google::protobuf::Message {
 public:
  CategoriesResponse();
  virtual ~CategoriesResponse();
  
  CategoriesResponse(const CategoriesResponse& from);
  
  inline CategoriesResponse& operator=(const CategoriesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CategoriesResponse& default_instance();
  
  void Swap(CategoriesResponse* other);
  
  // implements Message ----------------------------------------------
  
  CategoriesResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CategoriesResponse& from);
  void MergeFrom(const CategoriesResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .Category categories = 1;
  inline int categories_size() const;
  inline void clear_categories();
  static const int kCategoriesFieldNumber = 1;
  inline const ::Category& categories(int index) const;
  inline ::Category* mutable_categories(int index);
  inline ::Category* add_categories();
  inline const ::google::protobuf::RepeatedPtrField< ::Category >&
      categories() const;
  inline ::google::protobuf::RepeatedPtrField< ::Category >*
      mutable_categories();
  
  // @@protoc_insertion_point(class_scope:CategoriesResponse)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::Category > categories_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_market_2eproto();
  friend void protobuf_AssignDesc_market_2eproto();
  friend void protobuf_ShutdownFile_market_2eproto();
  
  void InitAsDefaultInstance();
  static CategoriesResponse* default_instance_;
};
// -------------------------------------------------------------------

class SubCategoriesRequest : public ::google::protobuf::Message {
 public:
  SubCategoriesRequest();
  virtual ~SubCategoriesRequest();
  
  SubCategoriesRequest(const SubCategoriesRequest& from);
  
  inline SubCategoriesRequest& operator=(const SubCategoriesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SubCategoriesRequest& default_instance();
  
  void Swap(SubCategoriesRequest* other);
  
  // implements Message ----------------------------------------------
  
  SubCategoriesRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubCategoriesRequest& from);
  void MergeFrom(const SubCategoriesRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .AppType appType = 1;
  inline bool has_apptype() const;
  inline void clear_apptype();
  static const int kAppTypeFieldNumber = 1;
  inline AppType apptype() const;
  inline void set_apptype(AppType value);
  
  // @@protoc_insertion_point(class_scope:SubCategoriesRequest)
 private:
  inline void set_has_apptype();
  inline void clear_has_apptype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int apptype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_market_2eproto();
  friend void protobuf_AssignDesc_market_2eproto();
  friend void protobuf_ShutdownFile_market_2eproto();
  
  void InitAsDefaultInstance();
  static SubCategoriesRequest* default_instance_;
};
// -------------------------------------------------------------------

class SubCategoriesResponse : public ::google::protobuf::Message {
 public:
  SubCategoriesResponse();
  virtual ~SubCategoriesResponse();
  
  SubCategoriesResponse(const SubCategoriesResponse& from);
  
  inline SubCategoriesResponse& operator=(const SubCategoriesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SubCategoriesResponse& default_instance();
  
  void Swap(SubCategoriesResponse* other);
  
  // implements Message ----------------------------------------------
  
  SubCategoriesResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubCategoriesResponse& from);
  void MergeFrom(const SubCategoriesResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .Category category = 1;
  inline int category_size() const;
  inline void clear_category();
  static const int kCategoryFieldNumber = 1;
  inline const ::Category& category(int index) const;
  inline ::Category* mutable_category(int index);
  inline ::Category* add_category();
  inline const ::google::protobuf::RepeatedPtrField< ::Category >&
      category() const;
  inline ::google::protobuf::RepeatedPtrField< ::Category >*
      mutable_category();
  
  // optional string subCategoryDisplay = 2;
  inline bool has_subcategorydisplay() const;
  inline void clear_subcategorydisplay();
  static const int kSubCategoryDisplayFieldNumber = 2;
  inline const ::std::string& subcategorydisplay() const;
  inline void set_subcategorydisplay(const ::std::string& value);
  inline void set_subcategorydisplay(const char* value);
  inline void set_subcategorydisplay(const char* value, size_t size);
  inline ::std::string* mutable_subcategorydisplay();
  inline ::std::string* release_subcategorydisplay();
  
  // optional int32 subCategoryId = 3;
  inline bool has_subcategoryid() const;
  inline void clear_subcategoryid();
  static const int kSubCategoryIdFieldNumber = 3;
  inline ::google::protobuf::int32 subcategoryid() const;
  inline void set_subcategoryid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:SubCategoriesResponse)
 private:
  inline void set_has_subcategorydisplay();
  inline void clear_has_subcategorydisplay();
  inline void set_has_subcategoryid();
  inline void clear_has_subcategoryid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::Category > category_;
  ::std::string* subcategorydisplay_;
  ::google::protobuf::int32 subcategoryid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_market_2eproto();
  friend void protobuf_AssignDesc_market_2eproto();
  friend void protobuf_ShutdownFile_market_2eproto();
  
  void InitAsDefaultInstance();
  static SubCategoriesResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestContext : public ::google::protobuf::Message {
 public:
  RequestContext();
  virtual ~RequestContext();
  
  RequestContext(const RequestContext& from);
  
  inline RequestContext& operator=(const RequestContext& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestContext& default_instance();
  
  void Swap(RequestContext* other);
  
  // implements Message ----------------------------------------------
  
  RequestContext* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestContext& from);
  void MergeFrom(const RequestContext& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string authSubToken = 1;
  inline bool has_authsubtoken() const;
  inline void clear_authsubtoken();
  static const int kAuthSubTokenFieldNumber = 1;
  inline const ::std::string& authsubtoken() const;
  inline void set_authsubtoken(const ::std::string& value);
  inline void set_authsubtoken(const char* value);
  inline void set_authsubtoken(const char* value, size_t size);
  inline ::std::string* mutable_authsubtoken();
  inline ::std::string* release_authsubtoken();
  
  // required bool isSecure = 2;
  inline bool has_issecure() const;
  inline void clear_issecure();
  static const int kIsSecureFieldNumber = 2;
  inline bool issecure() const;
  inline void set_issecure(bool value);
  
  // required int32 version = 3;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 3;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);
  
  // required string androidId = 4;
  inline bool has_androidid() const;
  inline void clear_androidid();
  static const int kAndroidIdFieldNumber = 4;
  inline const ::std::string& androidid() const;
  inline void set_androidid(const ::std::string& value);
  inline void set_androidid(const char* value);
  inline void set_androidid(const char* value, size_t size);
  inline ::std::string* mutable_androidid();
  inline ::std::string* release_androidid();
  
  // optional string deviceAndSdkVersion = 5;
  inline bool has_deviceandsdkversion() const;
  inline void clear_deviceandsdkversion();
  static const int kDeviceAndSdkVersionFieldNumber = 5;
  inline const ::std::string& deviceandsdkversion() const;
  inline void set_deviceandsdkversion(const ::std::string& value);
  inline void set_deviceandsdkversion(const char* value);
  inline void set_deviceandsdkversion(const char* value, size_t size);
  inline ::std::string* mutable_deviceandsdkversion();
  inline ::std::string* release_deviceandsdkversion();
  
  // optional string userLanguage = 6;
  inline bool has_userlanguage() const;
  inline void clear_userlanguage();
  static const int kUserLanguageFieldNumber = 6;
  inline const ::std::string& userlanguage() const;
  inline void set_userlanguage(const ::std::string& value);
  inline void set_userlanguage(const char* value);
  inline void set_userlanguage(const char* value, size_t size);
  inline ::std::string* mutable_userlanguage();
  inline ::std::string* release_userlanguage();
  
  // optional string userCountry = 7;
  inline bool has_usercountry() const;
  inline void clear_usercountry();
  static const int kUserCountryFieldNumber = 7;
  inline const ::std::string& usercountry() const;
  inline void set_usercountry(const ::std::string& value);
  inline void set_usercountry(const char* value);
  inline void set_usercountry(const char* value, size_t size);
  inline ::std::string* mutable_usercountry();
  inline ::std::string* release_usercountry();
  
  // optional string operatorAlpha = 8;
  inline bool has_operatoralpha() const;
  inline void clear_operatoralpha();
  static const int kOperatorAlphaFieldNumber = 8;
  inline const ::std::string& operatoralpha() const;
  inline void set_operatoralpha(const ::std::string& value);
  inline void set_operatoralpha(const char* value);
  inline void set_operatoralpha(const char* value, size_t size);
  inline ::std::string* mutable_operatoralpha();
  inline ::std::string* release_operatoralpha();
  
  // optional string simOperatorAlpha = 9;
  inline bool has_simoperatoralpha() const;
  inline void clear_simoperatoralpha();
  static const int kSimOperatorAlphaFieldNumber = 9;
  inline const ::std::string& simoperatoralpha() const;
  inline void set_simoperatoralpha(const ::std::string& value);
  inline void set_simoperatoralpha(const char* value);
  inline void set_simoperatoralpha(const char* value, size_t size);
  inline ::std::string* mutable_simoperatoralpha();
  inline ::std::string* release_simoperatoralpha();
  
  // optional string operatorNumeric = 10;
  inline bool has_operatornumeric() const;
  inline void clear_operatornumeric();
  static const int kOperatorNumericFieldNumber = 10;
  inline const ::std::string& operatornumeric() const;
  inline void set_operatornumeric(const ::std::string& value);
  inline void set_operatornumeric(const char* value);
  inline void set_operatornumeric(const char* value, size_t size);
  inline ::std::string* mutable_operatornumeric();
  inline ::std::string* release_operatornumeric();
  
  // optional string simOperatorNumeric = 11;
  inline bool has_simoperatornumeric() const;
  inline void clear_simoperatornumeric();
  static const int kSimOperatorNumericFieldNumber = 11;
  inline const ::std::string& simoperatornumeric() const;
  inline void set_simoperatornumeric(const ::std::string& value);
  inline void set_simoperatornumeric(const char* value);
  inline void set_simoperatornumeric(const char* value, size_t size);
  inline ::std::string* mutable_simoperatornumeric();
  inline ::std::string* release_simoperatornumeric();
  
  // @@protoc_insertion_point(class_scope:RequestContext)
 private:
  inline void set_has_authsubtoken();
  inline void clear_has_authsubtoken();
  inline void set_has_issecure();
  inline void clear_has_issecure();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_androidid();
  inline void clear_has_androidid();
  inline void set_has_deviceandsdkversion();
  inline void clear_has_deviceandsdkversion();
  inline void set_has_userlanguage();
  inline void clear_has_userlanguage();
  inline void set_has_usercountry();
  inline void clear_has_usercountry();
  inline void set_has_operatoralpha();
  inline void clear_has_operatoralpha();
  inline void set_has_simoperatoralpha();
  inline void clear_has_simoperatoralpha();
  inline void set_has_operatornumeric();
  inline void clear_has_operatornumeric();
  inline void set_has_simoperatornumeric();
  inline void clear_has_simoperatornumeric();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* authsubtoken_;
  bool issecure_;
  ::google::protobuf::int32 version_;
  ::std::string* androidid_;
  ::std::string* deviceandsdkversion_;
  ::std::string* userlanguage_;
  ::std::string* usercountry_;
  ::std::string* operatoralpha_;
  ::std::string* simoperatoralpha_;
  ::std::string* operatornumeric_;
  ::std::string* simoperatornumeric_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  friend void  protobuf_AddDesc_market_2eproto();
  friend void protobuf_AssignDesc_market_2eproto();
  friend void protobuf_ShutdownFile_market_2eproto();
  
  void InitAsDefaultInstance();
  static RequestContext* default_instance_;
};
// -------------------------------------------------------------------

class GetImageRequest : public ::google::protobuf::Message {
 public:
  GetImageRequest();
  virtual ~GetImageRequest();
  
  GetImageRequest(const GetImageRequest& from);
  
  inline GetImageRequest& operator=(const GetImageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetImageRequest& default_instance();
  
  void Swap(GetImageRequest* other);
  
  // implements Message ----------------------------------------------
  
  GetImageRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetImageRequest& from);
  void MergeFrom(const GetImageRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef GetImageRequest_AppImageUsage AppImageUsage;
  static const AppImageUsage ICON = GetImageRequest_AppImageUsage_ICON;
  static const AppImageUsage SCREENSHOT = GetImageRequest_AppImageUsage_SCREENSHOT;
  static const AppImageUsage SCREENSHOT_THUMBNAIL = GetImageRequest_AppImageUsage_SCREENSHOT_THUMBNAIL;
  static const AppImageUsage PROMO_BADGE = GetImageRequest_AppImageUsage_PROMO_BADGE;
  static const AppImageUsage BILING_ICON = GetImageRequest_AppImageUsage_BILING_ICON;
  static inline bool AppImageUsage_IsValid(int value) {
    return GetImageRequest_AppImageUsage_IsValid(value);
  }
  static const AppImageUsage AppImageUsage_MIN =
    GetImageRequest_AppImageUsage_AppImageUsage_MIN;
  static const AppImageUsage AppImageUsage_MAX =
    GetImageRequest_AppImageUsage_AppImageUsage_MAX;
  static const int AppImageUsage_ARRAYSIZE =
    GetImageRequest_AppImageUsage_AppImageUsage_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  AppImageUsage_descriptor() {
    return GetImageRequest_AppImageUsage_descriptor();
  }
  static inline const ::std::string& AppImageUsage_Name(AppImageUsage value) {
    return GetImageRequest_AppImageUsage_Name(value);
  }
  static inline bool AppImageUsage_Parse(const ::std::string& name,
      AppImageUsage* value) {
    return GetImageRequest_AppImageUsage_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional string appId = 1;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIdFieldNumber = 1;
  inline const ::std::string& appid() const;
  inline void set_appid(const ::std::string& value);
  inline void set_appid(const char* value);
  inline void set_appid(const char* value, size_t size);
  inline ::std::string* mutable_appid();
  inline ::std::string* release_appid();
  
  // optional .GetImageRequest.AppImageUsage imageUsage = 3;
  inline bool has_imageusage() const;
  inline void clear_imageusage();
  static const int kImageUsageFieldNumber = 3;
  inline ::GetImageRequest_AppImageUsage imageusage() const;
  inline void set_imageusage(::GetImageRequest_AppImageUsage value);
  
  // optional string imageId = 4;
  inline bool has_imageid() const;
  inline void clear_imageid();
  static const int kImageIdFieldNumber = 4;
  inline const ::std::string& imageid() const;
  inline void set_imageid(const ::std::string& value);
  inline void set_imageid(const char* value);
  inline void set_imageid(const char* value, size_t size);
  inline ::std::string* mutable_imageid();
  inline ::std::string* release_imageid();
  
  // @@protoc_insertion_point(class_scope:GetImageRequest)
 private:
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_imageusage();
  inline void clear_has_imageusage();
  inline void set_has_imageid();
  inline void clear_has_imageid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* appid_;
  ::std::string* imageid_;
  int imageusage_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_market_2eproto();
  friend void protobuf_AssignDesc_market_2eproto();
  friend void protobuf_ShutdownFile_market_2eproto();
  
  void InitAsDefaultInstance();
  static GetImageRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetAssetRequest : public ::google::protobuf::Message {
 public:
  GetAssetRequest();
  virtual ~GetAssetRequest();
  
  GetAssetRequest(const GetAssetRequest& from);
  
  inline GetAssetRequest& operator=(const GetAssetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAssetRequest& default_instance();
  
  void Swap(GetAssetRequest* other);
  
  // implements Message ----------------------------------------------
  
  GetAssetRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetAssetRequest& from);
  void MergeFrom(const GetAssetRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string assetId = 1;
  inline bool has_assetid() const;
  inline void clear_assetid();
  static const int kAssetIdFieldNumber = 1;
  inline const ::std::string& assetid() const;
  inline void set_assetid(const ::std::string& value);
  inline void set_assetid(const char* value);
  inline void set_assetid(const char* value, size_t size);
  inline ::std::string* mutable_assetid();
  inline ::std::string* release_assetid();
  
  // optional string directDownloadKey = 2;
  inline bool has_directdownloadkey() const;
  inline void clear_directdownloadkey();
  static const int kDirectDownloadKeyFieldNumber = 2;
  inline const ::std::string& directdownloadkey() const;
  inline void set_directdownloadkey(const ::std::string& value);
  inline void set_directdownloadkey(const char* value);
  inline void set_directdownloadkey(const char* value, size_t size);
  inline ::std::string* mutable_directdownloadkey();
  inline ::std::string* release_directdownloadkey();
  
  // @@protoc_insertion_point(class_scope:GetAssetRequest)
 private:
  inline void set_has_assetid();
  inline void clear_has_assetid();
  inline void set_has_directdownloadkey();
  inline void clear_has_directdownloadkey();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* assetid_;
  ::std::string* directdownloadkey_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_market_2eproto();
  friend void protobuf_AssignDesc_market_2eproto();
  friend void protobuf_ShutdownFile_market_2eproto();
  
  void InitAsDefaultInstance();
  static GetAssetRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetImageResponse : public ::google::protobuf::Message {
 public:
  GetImageResponse();
  virtual ~GetImageResponse();
  
  GetImageResponse(const GetImageResponse& from);
  
  inline GetImageResponse& operator=(const GetImageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetImageResponse& default_instance();
  
  void Swap(GetImageResponse* other);
  
  // implements Message ----------------------------------------------
  
  GetImageResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetImageResponse& from);
  void MergeFrom(const GetImageResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes imageData = 1;
  inline bool has_imagedata() const;
  inline void clear_imagedata();
  static const int kImageDataFieldNumber = 1;
  inline const ::std::string& imagedata() const;
  inline void set_imagedata(const ::std::string& value);
  inline void set_imagedata(const char* value);
  inline void set_imagedata(const void* value, size_t size);
  inline ::std::string* mutable_imagedata();
  inline ::std::string* release_imagedata();
  
  // @@protoc_insertion_point(class_scope:GetImageResponse)
 private:
  inline void set_has_imagedata();
  inline void clear_has_imagedata();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* imagedata_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_market_2eproto();
  friend void protobuf_AssignDesc_market_2eproto();
  friend void protobuf_ShutdownFile_market_2eproto();
  
  void InitAsDefaultInstance();
  static GetImageResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetAssetResponse_InstallAsset : public ::google::protobuf::Message {
 public:
  GetAssetResponse_InstallAsset();
  virtual ~GetAssetResponse_InstallAsset();
  
  GetAssetResponse_InstallAsset(const GetAssetResponse_InstallAsset& from);
  
  inline GetAssetResponse_InstallAsset& operator=(const GetAssetResponse_InstallAsset& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAssetResponse_InstallAsset& default_instance();
  
  void Swap(GetAssetResponse_InstallAsset* other);
  
  // implements Message ----------------------------------------------
  
  GetAssetResponse_InstallAsset* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetAssetResponse_InstallAsset& from);
  void MergeFrom(const GetAssetResponse_InstallAsset& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string assetId = 2;
  inline bool has_assetid() const;
  inline void clear_assetid();
  static const int kAssetIdFieldNumber = 2;
  inline const ::std::string& assetid() const;
  inline void set_assetid(const ::std::string& value);
  inline void set_assetid(const char* value);
  inline void set_assetid(const char* value, size_t size);
  inline ::std::string* mutable_assetid();
  inline ::std::string* release_assetid();
  
  // optional string assetName = 3;
  inline bool has_assetname() const;
  inline void clear_assetname();
  static const int kAssetNameFieldNumber = 3;
  inline const ::std::string& assetname() const;
  inline void set_assetname(const ::std::string& value);
  inline void set_assetname(const char* value);
  inline void set_assetname(const char* value, size_t size);
  inline ::std::string* mutable_assetname();
  inline ::std::string* release_assetname();
  
  // optional string assetType = 4;
  inline bool has_assettype() const;
  inline void clear_assettype();
  static const int kAssetTypeFieldNumber = 4;
  inline const ::std::string& assettype() const;
  inline void set_assettype(const ::std::string& value);
  inline void set_assettype(const char* value);
  inline void set_assettype(const char* value, size_t size);
  inline ::std::string* mutable_assettype();
  inline ::std::string* release_assettype();
  
  // optional string assetPackage = 5;
  inline bool has_assetpackage() const;
  inline void clear_assetpackage();
  static const int kAssetPackageFieldNumber = 5;
  inline const ::std::string& assetpackage() const;
  inline void set_assetpackage(const ::std::string& value);
  inline void set_assetpackage(const char* value);
  inline void set_assetpackage(const char* value, size_t size);
  inline ::std::string* mutable_assetpackage();
  inline ::std::string* release_assetpackage();
  
  // optional string blobUrl = 6;
  inline bool has_bloburl() const;
  inline void clear_bloburl();
  static const int kBlobUrlFieldNumber = 6;
  inline const ::std::string& bloburl() const;
  inline void set_bloburl(const ::std::string& value);
  inline void set_bloburl(const char* value);
  inline void set_bloburl(const char* value, size_t size);
  inline ::std::string* mutable_bloburl();
  inline ::std::string* release_bloburl();
  
  // optional string assetSignature = 7;
  inline bool has_assetsignature() const;
  inline void clear_assetsignature();
  static const int kAssetSignatureFieldNumber = 7;
  inline const ::std::string& assetsignature() const;
  inline void set_assetsignature(const ::std::string& value);
  inline void set_assetsignature(const char* value);
  inline void set_assetsignature(const char* value, size_t size);
  inline ::std::string* mutable_assetsignature();
  inline ::std::string* release_assetsignature();
  
  // optional uint64 assetSize = 8;
  inline bool has_assetsize() const;
  inline void clear_assetsize();
  static const int kAssetSizeFieldNumber = 8;
  inline ::google::protobuf::uint64 assetsize() const;
  inline void set_assetsize(::google::protobuf::uint64 value);
  
  // optional uint64 refundTimeout = 9;
  inline bool has_refundtimeout() const;
  inline void clear_refundtimeout();
  static const int kRefundTimeoutFieldNumber = 9;
  inline ::google::protobuf::uint64 refundtimeout() const;
  inline void set_refundtimeout(::google::protobuf::uint64 value);
  
  // optional bool forwardLocked = 10;
  inline bool has_forwardlocked() const;
  inline void clear_forwardlocked();
  static const int kForwardLockedFieldNumber = 10;
  inline bool forwardlocked() const;
  inline void set_forwardlocked(bool value);
  
  // optional bool secured = 11;
  inline bool has_secured() const;
  inline void clear_secured();
  static const int kSecuredFieldNumber = 11;
  inline bool secured() const;
  inline void set_secured(bool value);
  
  // optional int32 versionCode = 12;
  inline bool has_versioncode() const;
  inline void clear_versioncode();
  static const int kVersionCodeFieldNumber = 12;
  inline ::google::protobuf::int32 versioncode() const;
  inline void set_versioncode(::google::protobuf::int32 value);
  
  // optional string downloadAuthCookieName = 13;
  inline bool has_downloadauthcookiename() const;
  inline void clear_downloadauthcookiename();
  static const int kDownloadAuthCookieNameFieldNumber = 13;
  inline const ::std::string& downloadauthcookiename() const;
  inline void set_downloadauthcookiename(const ::std::string& value);
  inline void set_downloadauthcookiename(const char* value);
  inline void set_downloadauthcookiename(const char* value, size_t size);
  inline ::std::string* mutable_downloadauthcookiename();
  inline ::std::string* release_downloadauthcookiename();
  
  // optional string downloadAuthCookieValue = 14;
  inline bool has_downloadauthcookievalue() const;
  inline void clear_downloadauthcookievalue();
  static const int kDownloadAuthCookieValueFieldNumber = 14;
  inline const ::std::string& downloadauthcookievalue() const;
  inline void set_downloadauthcookievalue(const ::std::string& value);
  inline void set_downloadauthcookievalue(const char* value);
  inline void set_downloadauthcookievalue(const char* value, size_t size);
  inline ::std::string* mutable_downloadauthcookievalue();
  inline ::std::string* release_downloadauthcookievalue();
  
  // @@protoc_insertion_point(class_scope:GetAssetResponse.InstallAsset)
 private:
  inline void set_has_assetid();
  inline void clear_has_assetid();
  inline void set_has_assetname();
  inline void clear_has_assetname();
  inline void set_has_assettype();
  inline void clear_has_assettype();
  inline void set_has_assetpackage();
  inline void clear_has_assetpackage();
  inline void set_has_bloburl();
  inline void clear_has_bloburl();
  inline void set_has_assetsignature();
  inline void clear_has_assetsignature();
  inline void set_has_assetsize();
  inline void clear_has_assetsize();
  inline void set_has_refundtimeout();
  inline void clear_has_refundtimeout();
  inline void set_has_forwardlocked();
  inline void clear_has_forwardlocked();
  inline void set_has_secured();
  inline void clear_has_secured();
  inline void set_has_versioncode();
  inline void clear_has_versioncode();
  inline void set_has_downloadauthcookiename();
  inline void clear_has_downloadauthcookiename();
  inline void set_has_downloadauthcookievalue();
  inline void clear_has_downloadauthcookievalue();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* assetid_;
  ::std::string* assetname_;
  ::std::string* assettype_;
  ::std::string* assetpackage_;
  ::std::string* bloburl_;
  ::std::string* assetsignature_;
  ::google::protobuf::uint64 assetsize_;
  ::google::protobuf::uint64 refundtimeout_;
  bool forwardlocked_;
  bool secured_;
  ::google::protobuf::int32 versioncode_;
  ::std::string* downloadauthcookiename_;
  ::std::string* downloadauthcookievalue_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];
  
  friend void  protobuf_AddDesc_market_2eproto();
  friend void protobuf_AssignDesc_market_2eproto();
  friend void protobuf_ShutdownFile_market_2eproto();
  
  void InitAsDefaultInstance();
  static GetAssetResponse_InstallAsset* default_instance_;
};
// -------------------------------------------------------------------

class GetAssetResponse : public ::google::protobuf::Message {
 public:
  GetAssetResponse();
  virtual ~GetAssetResponse();
  
  GetAssetResponse(const GetAssetResponse& from);
  
  inline GetAssetResponse& operator=(const GetAssetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAssetResponse& default_instance();
  
  void Swap(GetAssetResponse* other);
  
  // implements Message ----------------------------------------------
  
  GetAssetResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetAssetResponse& from);
  void MergeFrom(const GetAssetResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef GetAssetResponse_InstallAsset InstallAsset;
  
  // accessors -------------------------------------------------------
  
  // repeated group InstallAsset = 1 {
  inline int installasset_size() const;
  inline void clear_installasset();
  static const int kInstallassetFieldNumber = 1;
  inline const ::GetAssetResponse_InstallAsset& installasset(int index) const;
  inline ::GetAssetResponse_InstallAsset* mutable_installasset(int index);
  inline ::GetAssetResponse_InstallAsset* add_installasset();
  inline const ::google::protobuf::RepeatedPtrField< ::GetAssetResponse_InstallAsset >&
      installasset() const;
  inline ::google::protobuf::RepeatedPtrField< ::GetAssetResponse_InstallAsset >*
      mutable_installasset();
  
  // @@protoc_insertion_point(class_scope:GetAssetResponse)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::GetAssetResponse_InstallAsset > installasset_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_market_2eproto();
  friend void protobuf_AssignDesc_market_2eproto();
  friend void protobuf_ShutdownFile_market_2eproto();
  
  void InitAsDefaultInstance();
  static GetAssetResponse* default_instance_;
};
// -------------------------------------------------------------------

class Request_RequestGroup : public ::google::protobuf::Message {
 public:
  Request_RequestGroup();
  virtual ~Request_RequestGroup();
  
  Request_RequestGroup(const Request_RequestGroup& from);
  
  inline Request_RequestGroup& operator=(const Request_RequestGroup& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Request_RequestGroup& default_instance();
  
  void Swap(Request_RequestGroup* other);
  
  // implements Message ----------------------------------------------
  
  Request_RequestGroup* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request_RequestGroup& from);
  void MergeFrom(const Request_RequestGroup& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .AppsRequest appsRequest = 4;
  inline bool has_appsrequest() const;
  inline void clear_appsrequest();
  static const int kAppsRequestFieldNumber = 4;
  inline const ::AppsRequest& appsrequest() const;
  inline ::AppsRequest* mutable_appsrequest();
  inline ::AppsRequest* release_appsrequest();
  
  // optional .CommentsRequest commentsRequest = 5;
  inline bool has_commentsrequest() const;
  inline void clear_commentsrequest();
  static const int kCommentsRequestFieldNumber = 5;
  inline const ::CommentsRequest& commentsrequest() const;
  inline ::CommentsRequest* mutable_commentsrequest();
  inline ::CommentsRequest* release_commentsrequest();
  
  // optional .GetAssetRequest getAssetRequest = 10;
  inline bool has_getassetrequest() const;
  inline void clear_getassetrequest();
  static const int kGetAssetRequestFieldNumber = 10;
  inline const ::GetAssetRequest& getassetrequest() const;
  inline ::GetAssetRequest* mutable_getassetrequest();
  inline ::GetAssetRequest* release_getassetrequest();
  
  // optional .GetImageRequest imageRequest = 11;
  inline bool has_imagerequest() const;
  inline void clear_imagerequest();
  static const int kImageRequestFieldNumber = 11;
  inline const ::GetImageRequest& imagerequest() const;
  inline ::GetImageRequest* mutable_imagerequest();
  inline ::GetImageRequest* release_imagerequest();
  
  // optional .SubCategoriesRequest subCategoriesRequest = 14;
  inline bool has_subcategoriesrequest() const;
  inline void clear_subcategoriesrequest();
  static const int kSubCategoriesRequestFieldNumber = 14;
  inline const ::SubCategoriesRequest& subcategoriesrequest() const;
  inline ::SubCategoriesRequest* mutable_subcategoriesrequest();
  inline ::SubCategoriesRequest* release_subcategoriesrequest();
  
  // optional .CategoriesRequest categoriesRequest = 21;
  inline bool has_categoriesrequest() const;
  inline void clear_categoriesrequest();
  static const int kCategoriesRequestFieldNumber = 21;
  inline const ::CategoriesRequest& categoriesrequest() const;
  inline ::CategoriesRequest* mutable_categoriesrequest();
  inline ::CategoriesRequest* release_categoriesrequest();
  
  // @@protoc_insertion_point(class_scope:Request.RequestGroup)
 private:
  inline void set_has_appsrequest();
  inline void clear_has_appsrequest();
  inline void set_has_commentsrequest();
  inline void clear_has_commentsrequest();
  inline void set_has_getassetrequest();
  inline void clear_has_getassetrequest();
  inline void set_has_imagerequest();
  inline void clear_has_imagerequest();
  inline void set_has_subcategoriesrequest();
  inline void clear_has_subcategoriesrequest();
  inline void set_has_categoriesrequest();
  inline void clear_has_categoriesrequest();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::AppsRequest* appsrequest_;
  ::CommentsRequest* commentsrequest_;
  ::GetAssetRequest* getassetrequest_;
  ::GetImageRequest* imagerequest_;
  ::SubCategoriesRequest* subcategoriesrequest_;
  ::CategoriesRequest* categoriesrequest_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_market_2eproto();
  friend void protobuf_AssignDesc_market_2eproto();
  friend void protobuf_ShutdownFile_market_2eproto();
  
  void InitAsDefaultInstance();
  static Request_RequestGroup* default_instance_;
};
// -------------------------------------------------------------------

class Request : public ::google::protobuf::Message {
 public:
  Request();
  virtual ~Request();
  
  Request(const Request& from);
  
  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();
  
  void Swap(Request* other);
  
  // implements Message ----------------------------------------------
  
  Request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Request_RequestGroup RequestGroup;
  
  // accessors -------------------------------------------------------
  
  // optional .RequestContext context = 1;
  inline bool has_context() const;
  inline void clear_context();
  static const int kContextFieldNumber = 1;
  inline const ::RequestContext& context() const;
  inline ::RequestContext* mutable_context();
  inline ::RequestContext* release_context();
  
  // repeated group RequestGroup = 2 {
  inline int requestgroup_size() const;
  inline void clear_requestgroup();
  static const int kRequestgroupFieldNumber = 2;
  inline const ::Request_RequestGroup& requestgroup(int index) const;
  inline ::Request_RequestGroup* mutable_requestgroup(int index);
  inline ::Request_RequestGroup* add_requestgroup();
  inline const ::google::protobuf::RepeatedPtrField< ::Request_RequestGroup >&
      requestgroup() const;
  inline ::google::protobuf::RepeatedPtrField< ::Request_RequestGroup >*
      mutable_requestgroup();
  
  // @@protoc_insertion_point(class_scope:Request)
 private:
  inline void set_has_context();
  inline void clear_has_context();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::RequestContext* context_;
  ::google::protobuf::RepeatedPtrField< ::Request_RequestGroup > requestgroup_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_market_2eproto();
  friend void protobuf_AssignDesc_market_2eproto();
  friend void protobuf_ShutdownFile_market_2eproto();
  
  void InitAsDefaultInstance();
  static Request* default_instance_;
};
// -------------------------------------------------------------------

class ResponseContext : public ::google::protobuf::Message {
 public:
  ResponseContext();
  virtual ~ResponseContext();
  
  ResponseContext(const ResponseContext& from);
  
  inline ResponseContext& operator=(const ResponseContext& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseContext& default_instance();
  
  void Swap(ResponseContext* other);
  
  // implements Message ----------------------------------------------
  
  ResponseContext* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseContext& from);
  void MergeFrom(const ResponseContext& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef ResponseContext_ResultType ResultType;
  static const ResultType OK = ResponseContext_ResultType_OK;
  static const ResultType BAD_REQUEST = ResponseContext_ResultType_BAD_REQUEST;
  static const ResultType INTERNAL_SERVICE_ERROR = ResponseContext_ResultType_INTERNAL_SERVICE_ERROR;
  static const ResultType NOT_MODIFIED = ResponseContext_ResultType_NOT_MODIFIED;
  static const ResultType USER_INPUT_ERROR = ResponseContext_ResultType_USER_INPUT_ERROR;
  static inline bool ResultType_IsValid(int value) {
    return ResponseContext_ResultType_IsValid(value);
  }
  static const ResultType ResultType_MIN =
    ResponseContext_ResultType_ResultType_MIN;
  static const ResultType ResultType_MAX =
    ResponseContext_ResultType_ResultType_MAX;
  static const int ResultType_ARRAYSIZE =
    ResponseContext_ResultType_ResultType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ResultType_descriptor() {
    return ResponseContext_ResultType_descriptor();
  }
  static inline const ::std::string& ResultType_Name(ResultType value) {
    return ResponseContext_ResultType_Name(value);
  }
  static inline bool ResultType_Parse(const ::std::string& name,
      ResultType* value) {
    return ResponseContext_ResultType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional .ResponseContext.ResultType result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::ResponseContext_ResultType result() const;
  inline void set_result(::ResponseContext_ResultType value);
  
  // optional int32 maxAge = 2;
  inline bool has_maxage() const;
  inline void clear_maxage();
  static const int kMaxAgeFieldNumber = 2;
  inline ::google::protobuf::int32 maxage() const;
  inline void set_maxage(::google::protobuf::int32 value);
  
  // optional string etag = 3;
  inline bool has_etag() const;
  inline void clear_etag();
  static const int kEtagFieldNumber = 3;
  inline const ::std::string& etag() const;
  inline void set_etag(const ::std::string& value);
  inline void set_etag(const char* value);
  inline void set_etag(const char* value, size_t size);
  inline ::std::string* mutable_etag();
  inline ::std::string* release_etag();
  
  // optional int32 serverVersion = 4;
  inline bool has_serverversion() const;
  inline void clear_serverversion();
  static const int kServerVersionFieldNumber = 4;
  inline ::google::protobuf::int32 serverversion() const;
  inline void set_serverversion(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:ResponseContext)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_maxage();
  inline void clear_has_maxage();
  inline void set_has_etag();
  inline void clear_has_etag();
  inline void set_has_serverversion();
  inline void clear_has_serverversion();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int result_;
  ::google::protobuf::int32 maxage_;
  ::std::string* etag_;
  ::google::protobuf::int32 serverversion_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_market_2eproto();
  friend void protobuf_AssignDesc_market_2eproto();
  friend void protobuf_ShutdownFile_market_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseContext* default_instance_;
};
// -------------------------------------------------------------------

class Response_ResponseGroup : public ::google::protobuf::Message {
 public:
  Response_ResponseGroup();
  virtual ~Response_ResponseGroup();
  
  Response_ResponseGroup(const Response_ResponseGroup& from);
  
  inline Response_ResponseGroup& operator=(const Response_ResponseGroup& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_ResponseGroup& default_instance();
  
  void Swap(Response_ResponseGroup* other);
  
  // implements Message ----------------------------------------------
  
  Response_ResponseGroup* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response_ResponseGroup& from);
  void MergeFrom(const Response_ResponseGroup& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .ResponseContext context = 2;
  inline bool has_context() const;
  inline void clear_context();
  static const int kContextFieldNumber = 2;
  inline const ::ResponseContext& context() const;
  inline ::ResponseContext* mutable_context();
  inline ::ResponseContext* release_context();
  
  // optional .AppsResponse appsResponse = 3;
  inline bool has_appsresponse() const;
  inline void clear_appsresponse();
  static const int kAppsResponseFieldNumber = 3;
  inline const ::AppsResponse& appsresponse() const;
  inline ::AppsResponse* mutable_appsresponse();
  inline ::AppsResponse* release_appsresponse();
  
  // optional .CommentsResponse commentsResponse = 4;
  inline bool has_commentsresponse() const;
  inline void clear_commentsresponse();
  static const int kCommentsResponseFieldNumber = 4;
  inline const ::CommentsResponse& commentsresponse() const;
  inline ::CommentsResponse* mutable_commentsresponse();
  inline ::CommentsResponse* release_commentsresponse();
  
  // optional .GetAssetResponse getAssetResponse = 9;
  inline bool has_getassetresponse() const;
  inline void clear_getassetresponse();
  static const int kGetAssetResponseFieldNumber = 9;
  inline const ::GetAssetResponse& getassetresponse() const;
  inline ::GetAssetResponse* mutable_getassetresponse();
  inline ::GetAssetResponse* release_getassetresponse();
  
  // optional .GetImageResponse imageResponse = 10;
  inline bool has_imageresponse() const;
  inline void clear_imageresponse();
  static const int kImageResponseFieldNumber = 10;
  inline const ::GetImageResponse& imageresponse() const;
  inline ::GetImageResponse* mutable_imageresponse();
  inline ::GetImageResponse* release_imageresponse();
  
  // optional .CategoriesResponse categoriesResponse = 20;
  inline bool has_categoriesresponse() const;
  inline void clear_categoriesresponse();
  static const int kCategoriesResponseFieldNumber = 20;
  inline const ::CategoriesResponse& categoriesresponse() const;
  inline ::CategoriesResponse* mutable_categoriesresponse();
  inline ::CategoriesResponse* release_categoriesresponse();
  
  // optional .SubCategoriesResponse subCategoriesResponse = 13;
  inline bool has_subcategoriesresponse() const;
  inline void clear_subcategoriesresponse();
  static const int kSubCategoriesResponseFieldNumber = 13;
  inline const ::SubCategoriesResponse& subcategoriesresponse() const;
  inline ::SubCategoriesResponse* mutable_subcategoriesresponse();
  inline ::SubCategoriesResponse* release_subcategoriesresponse();
  
  // @@protoc_insertion_point(class_scope:Response.ResponseGroup)
 private:
  inline void set_has_context();
  inline void clear_has_context();
  inline void set_has_appsresponse();
  inline void clear_has_appsresponse();
  inline void set_has_commentsresponse();
  inline void clear_has_commentsresponse();
  inline void set_has_getassetresponse();
  inline void clear_has_getassetresponse();
  inline void set_has_imageresponse();
  inline void clear_has_imageresponse();
  inline void set_has_categoriesresponse();
  inline void clear_has_categoriesresponse();
  inline void set_has_subcategoriesresponse();
  inline void clear_has_subcategoriesresponse();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::ResponseContext* context_;
  ::AppsResponse* appsresponse_;
  ::CommentsResponse* commentsresponse_;
  ::GetAssetResponse* getassetresponse_;
  ::GetImageResponse* imageresponse_;
  ::CategoriesResponse* categoriesresponse_;
  ::SubCategoriesResponse* subcategoriesresponse_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_market_2eproto();
  friend void protobuf_AssignDesc_market_2eproto();
  friend void protobuf_ShutdownFile_market_2eproto();
  
  void InitAsDefaultInstance();
  static Response_ResponseGroup* default_instance_;
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message {
 public:
  Response();
  virtual ~Response();
  
  Response(const Response& from);
  
  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();
  
  void Swap(Response* other);
  
  // implements Message ----------------------------------------------
  
  Response* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Response_ResponseGroup ResponseGroup;
  
  // accessors -------------------------------------------------------
  
  // repeated group ResponseGroup = 1 {
  inline int responsegroup_size() const;
  inline void clear_responsegroup();
  static const int kResponsegroupFieldNumber = 1;
  inline const ::Response_ResponseGroup& responsegroup(int index) const;
  inline ::Response_ResponseGroup* mutable_responsegroup(int index);
  inline ::Response_ResponseGroup* add_responsegroup();
  inline const ::google::protobuf::RepeatedPtrField< ::Response_ResponseGroup >&
      responsegroup() const;
  inline ::google::protobuf::RepeatedPtrField< ::Response_ResponseGroup >*
      mutable_responsegroup();
  
  // @@protoc_insertion_point(class_scope:Response)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::Response_ResponseGroup > responsegroup_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_market_2eproto();
  friend void protobuf_AssignDesc_market_2eproto();
  friend void protobuf_ShutdownFile_market_2eproto();
  
  void InitAsDefaultInstance();
  static Response* default_instance_;
};
// ===================================================================


// ===================================================================

// AppsRequest

// optional .AppType appType = 1;
inline bool AppsRequest::has_apptype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AppsRequest::set_has_apptype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AppsRequest::clear_has_apptype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AppsRequest::clear_apptype() {
  apptype_ = 0;
  clear_has_apptype();
}
inline AppType AppsRequest::apptype() const {
  return static_cast< AppType >(apptype_);
}
inline void AppsRequest::set_apptype(AppType value) {
  GOOGLE_DCHECK(AppType_IsValid(value));
  set_has_apptype();
  apptype_ = value;
}

// optional string query = 2;
inline bool AppsRequest::has_query() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AppsRequest::set_has_query() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AppsRequest::clear_has_query() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AppsRequest::clear_query() {
  if (query_ != &::google::protobuf::internal::kEmptyString) {
    query_->clear();
  }
  clear_has_query();
}
inline const ::std::string& AppsRequest::query() const {
  return *query_;
}
inline void AppsRequest::set_query(const ::std::string& value) {
  set_has_query();
  if (query_ == &::google::protobuf::internal::kEmptyString) {
    query_ = new ::std::string;
  }
  query_->assign(value);
}
inline void AppsRequest::set_query(const char* value) {
  set_has_query();
  if (query_ == &::google::protobuf::internal::kEmptyString) {
    query_ = new ::std::string;
  }
  query_->assign(value);
}
inline void AppsRequest::set_query(const char* value, size_t size) {
  set_has_query();
  if (query_ == &::google::protobuf::internal::kEmptyString) {
    query_ = new ::std::string;
  }
  query_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AppsRequest::mutable_query() {
  set_has_query();
  if (query_ == &::google::protobuf::internal::kEmptyString) {
    query_ = new ::std::string;
  }
  return query_;
}
inline ::std::string* AppsRequest::release_query() {
  clear_has_query();
  if (query_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = query_;
    query_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string categoryId = 3;
inline bool AppsRequest::has_categoryid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AppsRequest::set_has_categoryid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AppsRequest::clear_has_categoryid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AppsRequest::clear_categoryid() {
  if (categoryid_ != &::google::protobuf::internal::kEmptyString) {
    categoryid_->clear();
  }
  clear_has_categoryid();
}
inline const ::std::string& AppsRequest::categoryid() const {
  return *categoryid_;
}
inline void AppsRequest::set_categoryid(const ::std::string& value) {
  set_has_categoryid();
  if (categoryid_ == &::google::protobuf::internal::kEmptyString) {
    categoryid_ = new ::std::string;
  }
  categoryid_->assign(value);
}
inline void AppsRequest::set_categoryid(const char* value) {
  set_has_categoryid();
  if (categoryid_ == &::google::protobuf::internal::kEmptyString) {
    categoryid_ = new ::std::string;
  }
  categoryid_->assign(value);
}
inline void AppsRequest::set_categoryid(const char* value, size_t size) {
  set_has_categoryid();
  if (categoryid_ == &::google::protobuf::internal::kEmptyString) {
    categoryid_ = new ::std::string;
  }
  categoryid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AppsRequest::mutable_categoryid() {
  set_has_categoryid();
  if (categoryid_ == &::google::protobuf::internal::kEmptyString) {
    categoryid_ = new ::std::string;
  }
  return categoryid_;
}
inline ::std::string* AppsRequest::release_categoryid() {
  clear_has_categoryid();
  if (categoryid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = categoryid_;
    categoryid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string appId = 4;
inline bool AppsRequest::has_appid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AppsRequest::set_has_appid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AppsRequest::clear_has_appid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AppsRequest::clear_appid() {
  if (appid_ != &::google::protobuf::internal::kEmptyString) {
    appid_->clear();
  }
  clear_has_appid();
}
inline const ::std::string& AppsRequest::appid() const {
  return *appid_;
}
inline void AppsRequest::set_appid(const ::std::string& value) {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    appid_ = new ::std::string;
  }
  appid_->assign(value);
}
inline void AppsRequest::set_appid(const char* value) {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    appid_ = new ::std::string;
  }
  appid_->assign(value);
}
inline void AppsRequest::set_appid(const char* value, size_t size) {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    appid_ = new ::std::string;
  }
  appid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AppsRequest::mutable_appid() {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    appid_ = new ::std::string;
  }
  return appid_;
}
inline ::std::string* AppsRequest::release_appid() {
  clear_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = appid_;
    appid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool withExtendedInfo = 6;
inline bool AppsRequest::has_withextendedinfo() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AppsRequest::set_has_withextendedinfo() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AppsRequest::clear_has_withextendedinfo() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AppsRequest::clear_withextendedinfo() {
  withextendedinfo_ = false;
  clear_has_withextendedinfo();
}
inline bool AppsRequest::withextendedinfo() const {
  return withextendedinfo_;
}
inline void AppsRequest::set_withextendedinfo(bool value) {
  set_has_withextendedinfo();
  withextendedinfo_ = value;
}

// optional .AppsRequest.OrderType orderType = 7 [default = NONE];
inline bool AppsRequest::has_ordertype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AppsRequest::set_has_ordertype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AppsRequest::clear_has_ordertype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AppsRequest::clear_ordertype() {
  ordertype_ = 0;
  clear_has_ordertype();
}
inline ::AppsRequest_OrderType AppsRequest::ordertype() const {
  return static_cast< ::AppsRequest_OrderType >(ordertype_);
}
inline void AppsRequest::set_ordertype(::AppsRequest_OrderType value) {
  GOOGLE_DCHECK(::AppsRequest_OrderType_IsValid(value));
  set_has_ordertype();
  ordertype_ = value;
}

// optional uint64 startIndex = 8;
inline bool AppsRequest::has_startindex() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AppsRequest::set_has_startindex() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AppsRequest::clear_has_startindex() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AppsRequest::clear_startindex() {
  startindex_ = GOOGLE_ULONGLONG(0);
  clear_has_startindex();
}
inline ::google::protobuf::uint64 AppsRequest::startindex() const {
  return startindex_;
}
inline void AppsRequest::set_startindex(::google::protobuf::uint64 value) {
  set_has_startindex();
  startindex_ = value;
}

// optional int32 entriesCount = 9;
inline bool AppsRequest::has_entriescount() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AppsRequest::set_has_entriescount() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AppsRequest::clear_has_entriescount() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AppsRequest::clear_entriescount() {
  entriescount_ = 0;
  clear_has_entriescount();
}
inline ::google::protobuf::int32 AppsRequest::entriescount() const {
  return entriescount_;
}
inline void AppsRequest::set_entriescount(::google::protobuf::int32 value) {
  set_has_entriescount();
  entriescount_ = value;
}

// optional .AppsRequest.ViewType viewType = 10 [default = ALL];
inline bool AppsRequest::has_viewtype() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AppsRequest::set_has_viewtype() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AppsRequest::clear_has_viewtype() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AppsRequest::clear_viewtype() {
  viewtype_ = 0;
  clear_has_viewtype();
}
inline ::AppsRequest_ViewType AppsRequest::viewtype() const {
  return static_cast< ::AppsRequest_ViewType >(viewtype_);
}
inline void AppsRequest::set_viewtype(::AppsRequest_ViewType value) {
  GOOGLE_DCHECK(::AppsRequest_ViewType_IsValid(value));
  set_has_viewtype();
  viewtype_ = value;
}

// -------------------------------------------------------------------

// AppsResponse

// repeated .App app = 1;
inline int AppsResponse::app_size() const {
  return app_.size();
}
inline void AppsResponse::clear_app() {
  app_.Clear();
}
inline const ::App& AppsResponse::app(int index) const {
  return app_.Get(index);
}
inline ::App* AppsResponse::mutable_app(int index) {
  return app_.Mutable(index);
}
inline ::App* AppsResponse::add_app() {
  return app_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::App >&
AppsResponse::app() const {
  return app_;
}
inline ::google::protobuf::RepeatedPtrField< ::App >*
AppsResponse::mutable_app() {
  return &app_;
}

// optional int32 entriesCount = 2;
inline bool AppsResponse::has_entriescount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AppsResponse::set_has_entriescount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AppsResponse::clear_has_entriescount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AppsResponse::clear_entriescount() {
  entriescount_ = 0;
  clear_has_entriescount();
}
inline ::google::protobuf::int32 AppsResponse::entriescount() const {
  return entriescount_;
}
inline void AppsResponse::set_entriescount(::google::protobuf::int32 value) {
  set_has_entriescount();
  entriescount_ = value;
}

// -------------------------------------------------------------------

// Category

// optional int32 appType = 2;
inline bool Category::has_apptype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Category::set_has_apptype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Category::clear_has_apptype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Category::clear_apptype() {
  apptype_ = 0;
  clear_has_apptype();
}
inline ::google::protobuf::int32 Category::apptype() const {
  return apptype_;
}
inline void Category::set_apptype(::google::protobuf::int32 value) {
  set_has_apptype();
  apptype_ = value;
}

// optional string title = 4;
inline bool Category::has_title() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Category::set_has_title() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Category::clear_has_title() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Category::clear_title() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& Category::title() const {
  return *title_;
}
inline void Category::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void Category::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void Category::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Category::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* Category::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string categoryId = 3;
inline bool Category::has_categoryid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Category::set_has_categoryid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Category::clear_has_categoryid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Category::clear_categoryid() {
  if (categoryid_ != &::google::protobuf::internal::kEmptyString) {
    categoryid_->clear();
  }
  clear_has_categoryid();
}
inline const ::std::string& Category::categoryid() const {
  return *categoryid_;
}
inline void Category::set_categoryid(const ::std::string& value) {
  set_has_categoryid();
  if (categoryid_ == &::google::protobuf::internal::kEmptyString) {
    categoryid_ = new ::std::string;
  }
  categoryid_->assign(value);
}
inline void Category::set_categoryid(const char* value) {
  set_has_categoryid();
  if (categoryid_ == &::google::protobuf::internal::kEmptyString) {
    categoryid_ = new ::std::string;
  }
  categoryid_->assign(value);
}
inline void Category::set_categoryid(const char* value, size_t size) {
  set_has_categoryid();
  if (categoryid_ == &::google::protobuf::internal::kEmptyString) {
    categoryid_ = new ::std::string;
  }
  categoryid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Category::mutable_categoryid() {
  set_has_categoryid();
  if (categoryid_ == &::google::protobuf::internal::kEmptyString) {
    categoryid_ = new ::std::string;
  }
  return categoryid_;
}
inline ::std::string* Category::release_categoryid() {
  clear_has_categoryid();
  if (categoryid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = categoryid_;
    categoryid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string subtitle = 5;
inline bool Category::has_subtitle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Category::set_has_subtitle() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Category::clear_has_subtitle() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Category::clear_subtitle() {
  if (subtitle_ != &::google::protobuf::internal::kEmptyString) {
    subtitle_->clear();
  }
  clear_has_subtitle();
}
inline const ::std::string& Category::subtitle() const {
  return *subtitle_;
}
inline void Category::set_subtitle(const ::std::string& value) {
  set_has_subtitle();
  if (subtitle_ == &::google::protobuf::internal::kEmptyString) {
    subtitle_ = new ::std::string;
  }
  subtitle_->assign(value);
}
inline void Category::set_subtitle(const char* value) {
  set_has_subtitle();
  if (subtitle_ == &::google::protobuf::internal::kEmptyString) {
    subtitle_ = new ::std::string;
  }
  subtitle_->assign(value);
}
inline void Category::set_subtitle(const char* value, size_t size) {
  set_has_subtitle();
  if (subtitle_ == &::google::protobuf::internal::kEmptyString) {
    subtitle_ = new ::std::string;
  }
  subtitle_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Category::mutable_subtitle() {
  set_has_subtitle();
  if (subtitle_ == &::google::protobuf::internal::kEmptyString) {
    subtitle_ = new ::std::string;
  }
  return subtitle_;
}
inline ::std::string* Category::release_subtitle() {
  clear_has_subtitle();
  if (subtitle_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subtitle_;
    subtitle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .Category subCategories = 8;
inline int Category::subcategories_size() const {
  return subcategories_.size();
}
inline void Category::clear_subcategories() {
  subcategories_.Clear();
}
inline const ::Category& Category::subcategories(int index) const {
  return subcategories_.Get(index);
}
inline ::Category* Category::mutable_subcategories(int index) {
  return subcategories_.Mutable(index);
}
inline ::Category* Category::add_subcategories() {
  return subcategories_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Category >&
Category::subcategories() const {
  return subcategories_;
}
inline ::google::protobuf::RepeatedPtrField< ::Category >*
Category::mutable_subcategories() {
  return &subcategories_;
}

// -------------------------------------------------------------------

// CommentsRequest

// optional string appId = 1;
inline bool CommentsRequest::has_appid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommentsRequest::set_has_appid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommentsRequest::clear_has_appid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommentsRequest::clear_appid() {
  if (appid_ != &::google::protobuf::internal::kEmptyString) {
    appid_->clear();
  }
  clear_has_appid();
}
inline const ::std::string& CommentsRequest::appid() const {
  return *appid_;
}
inline void CommentsRequest::set_appid(const ::std::string& value) {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    appid_ = new ::std::string;
  }
  appid_->assign(value);
}
inline void CommentsRequest::set_appid(const char* value) {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    appid_ = new ::std::string;
  }
  appid_->assign(value);
}
inline void CommentsRequest::set_appid(const char* value, size_t size) {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    appid_ = new ::std::string;
  }
  appid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommentsRequest::mutable_appid() {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    appid_ = new ::std::string;
  }
  return appid_;
}
inline ::std::string* CommentsRequest::release_appid() {
  clear_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = appid_;
    appid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 startIndex = 2;
inline bool CommentsRequest::has_startindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommentsRequest::set_has_startindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommentsRequest::clear_has_startindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommentsRequest::clear_startindex() {
  startindex_ = 0;
  clear_has_startindex();
}
inline ::google::protobuf::int32 CommentsRequest::startindex() const {
  return startindex_;
}
inline void CommentsRequest::set_startindex(::google::protobuf::int32 value) {
  set_has_startindex();
  startindex_ = value;
}

// optional int32 entriesCount = 3;
inline bool CommentsRequest::has_entriescount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommentsRequest::set_has_entriescount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommentsRequest::clear_has_entriescount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommentsRequest::clear_entriescount() {
  entriescount_ = 0;
  clear_has_entriescount();
}
inline ::google::protobuf::int32 CommentsRequest::entriescount() const {
  return entriescount_;
}
inline void CommentsRequest::set_entriescount(::google::protobuf::int32 value) {
  set_has_entriescount();
  entriescount_ = value;
}

// -------------------------------------------------------------------

// CommentsResponse

// repeated .Comment comments = 1;
inline int CommentsResponse::comments_size() const {
  return comments_.size();
}
inline void CommentsResponse::clear_comments() {
  comments_.Clear();
}
inline const ::Comment& CommentsResponse::comments(int index) const {
  return comments_.Get(index);
}
inline ::Comment* CommentsResponse::mutable_comments(int index) {
  return comments_.Mutable(index);
}
inline ::Comment* CommentsResponse::add_comments() {
  return comments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Comment >&
CommentsResponse::comments() const {
  return comments_;
}
inline ::google::protobuf::RepeatedPtrField< ::Comment >*
CommentsResponse::mutable_comments() {
  return &comments_;
}

// optional int32 entriesCount = 2;
inline bool CommentsResponse::has_entriescount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommentsResponse::set_has_entriescount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommentsResponse::clear_has_entriescount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommentsResponse::clear_entriescount() {
  entriescount_ = 0;
  clear_has_entriescount();
}
inline ::google::protobuf::int32 CommentsResponse::entriescount() const {
  return entriescount_;
}
inline void CommentsResponse::set_entriescount(::google::protobuf::int32 value) {
  set_has_entriescount();
  entriescount_ = value;
}

// -------------------------------------------------------------------

// App_ExtendedInfo

// optional string description = 13;
inline bool App_ExtendedInfo::has_description() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void App_ExtendedInfo::set_has_description() {
  _has_bits_[0] |= 0x00000001u;
}
inline void App_ExtendedInfo::clear_has_description() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void App_ExtendedInfo::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& App_ExtendedInfo::description() const {
  return *description_;
}
inline void App_ExtendedInfo::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void App_ExtendedInfo::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void App_ExtendedInfo::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* App_ExtendedInfo::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* App_ExtendedInfo::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 downloadsCount = 14;
inline bool App_ExtendedInfo::has_downloadscount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void App_ExtendedInfo::set_has_downloadscount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void App_ExtendedInfo::clear_has_downloadscount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void App_ExtendedInfo::clear_downloadscount() {
  downloadscount_ = 0;
  clear_has_downloadscount();
}
inline ::google::protobuf::int32 App_ExtendedInfo::downloadscount() const {
  return downloadscount_;
}
inline void App_ExtendedInfo::set_downloadscount(::google::protobuf::int32 value) {
  set_has_downloadscount();
  downloadscount_ = value;
}

// repeated string permissionId = 15;
inline int App_ExtendedInfo::permissionid_size() const {
  return permissionid_.size();
}
inline void App_ExtendedInfo::clear_permissionid() {
  permissionid_.Clear();
}
inline const ::std::string& App_ExtendedInfo::permissionid(int index) const {
  return permissionid_.Get(index);
}
inline ::std::string* App_ExtendedInfo::mutable_permissionid(int index) {
  return permissionid_.Mutable(index);
}
inline void App_ExtendedInfo::set_permissionid(int index, const ::std::string& value) {
  permissionid_.Mutable(index)->assign(value);
}
inline void App_ExtendedInfo::set_permissionid(int index, const char* value) {
  permissionid_.Mutable(index)->assign(value);
}
inline void App_ExtendedInfo::set_permissionid(int index, const char* value, size_t size) {
  permissionid_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* App_ExtendedInfo::add_permissionid() {
  return permissionid_.Add();
}
inline void App_ExtendedInfo::add_permissionid(const ::std::string& value) {
  permissionid_.Add()->assign(value);
}
inline void App_ExtendedInfo::add_permissionid(const char* value) {
  permissionid_.Add()->assign(value);
}
inline void App_ExtendedInfo::add_permissionid(const char* value, size_t size) {
  permissionid_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
App_ExtendedInfo::permissionid() const {
  return permissionid_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
App_ExtendedInfo::mutable_permissionid() {
  return &permissionid_;
}

// optional int32 installSize = 16;
inline bool App_ExtendedInfo::has_installsize() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void App_ExtendedInfo::set_has_installsize() {
  _has_bits_[0] |= 0x00000008u;
}
inline void App_ExtendedInfo::clear_has_installsize() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void App_ExtendedInfo::clear_installsize() {
  installsize_ = 0;
  clear_has_installsize();
}
inline ::google::protobuf::int32 App_ExtendedInfo::installsize() const {
  return installsize_;
}
inline void App_ExtendedInfo::set_installsize(::google::protobuf::int32 value) {
  set_has_installsize();
  installsize_ = value;
}

// optional string packageName = 17;
inline bool App_ExtendedInfo::has_packagename() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void App_ExtendedInfo::set_has_packagename() {
  _has_bits_[0] |= 0x00000010u;
}
inline void App_ExtendedInfo::clear_has_packagename() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void App_ExtendedInfo::clear_packagename() {
  if (packagename_ != &::google::protobuf::internal::kEmptyString) {
    packagename_->clear();
  }
  clear_has_packagename();
}
inline const ::std::string& App_ExtendedInfo::packagename() const {
  return *packagename_;
}
inline void App_ExtendedInfo::set_packagename(const ::std::string& value) {
  set_has_packagename();
  if (packagename_ == &::google::protobuf::internal::kEmptyString) {
    packagename_ = new ::std::string;
  }
  packagename_->assign(value);
}
inline void App_ExtendedInfo::set_packagename(const char* value) {
  set_has_packagename();
  if (packagename_ == &::google::protobuf::internal::kEmptyString) {
    packagename_ = new ::std::string;
  }
  packagename_->assign(value);
}
inline void App_ExtendedInfo::set_packagename(const char* value, size_t size) {
  set_has_packagename();
  if (packagename_ == &::google::protobuf::internal::kEmptyString) {
    packagename_ = new ::std::string;
  }
  packagename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* App_ExtendedInfo::mutable_packagename() {
  set_has_packagename();
  if (packagename_ == &::google::protobuf::internal::kEmptyString) {
    packagename_ = new ::std::string;
  }
  return packagename_;
}
inline ::std::string* App_ExtendedInfo::release_packagename() {
  clear_has_packagename();
  if (packagename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = packagename_;
    packagename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string category = 18;
inline bool App_ExtendedInfo::has_category() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void App_ExtendedInfo::set_has_category() {
  _has_bits_[0] |= 0x00000020u;
}
inline void App_ExtendedInfo::clear_has_category() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void App_ExtendedInfo::clear_category() {
  if (category_ != &::google::protobuf::internal::kEmptyString) {
    category_->clear();
  }
  clear_has_category();
}
inline const ::std::string& App_ExtendedInfo::category() const {
  return *category_;
}
inline void App_ExtendedInfo::set_category(const ::std::string& value) {
  set_has_category();
  if (category_ == &::google::protobuf::internal::kEmptyString) {
    category_ = new ::std::string;
  }
  category_->assign(value);
}
inline void App_ExtendedInfo::set_category(const char* value) {
  set_has_category();
  if (category_ == &::google::protobuf::internal::kEmptyString) {
    category_ = new ::std::string;
  }
  category_->assign(value);
}
inline void App_ExtendedInfo::set_category(const char* value, size_t size) {
  set_has_category();
  if (category_ == &::google::protobuf::internal::kEmptyString) {
    category_ = new ::std::string;
  }
  category_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* App_ExtendedInfo::mutable_category() {
  set_has_category();
  if (category_ == &::google::protobuf::internal::kEmptyString) {
    category_ = new ::std::string;
  }
  return category_;
}
inline ::std::string* App_ExtendedInfo::release_category() {
  clear_has_category();
  if (category_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = category_;
    category_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string contactEmail = 20;
inline bool App_ExtendedInfo::has_contactemail() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void App_ExtendedInfo::set_has_contactemail() {
  _has_bits_[0] |= 0x00000040u;
}
inline void App_ExtendedInfo::clear_has_contactemail() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void App_ExtendedInfo::clear_contactemail() {
  if (contactemail_ != &::google::protobuf::internal::kEmptyString) {
    contactemail_->clear();
  }
  clear_has_contactemail();
}
inline const ::std::string& App_ExtendedInfo::contactemail() const {
  return *contactemail_;
}
inline void App_ExtendedInfo::set_contactemail(const ::std::string& value) {
  set_has_contactemail();
  if (contactemail_ == &::google::protobuf::internal::kEmptyString) {
    contactemail_ = new ::std::string;
  }
  contactemail_->assign(value);
}
inline void App_ExtendedInfo::set_contactemail(const char* value) {
  set_has_contactemail();
  if (contactemail_ == &::google::protobuf::internal::kEmptyString) {
    contactemail_ = new ::std::string;
  }
  contactemail_->assign(value);
}
inline void App_ExtendedInfo::set_contactemail(const char* value, size_t size) {
  set_has_contactemail();
  if (contactemail_ == &::google::protobuf::internal::kEmptyString) {
    contactemail_ = new ::std::string;
  }
  contactemail_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* App_ExtendedInfo::mutable_contactemail() {
  set_has_contactemail();
  if (contactemail_ == &::google::protobuf::internal::kEmptyString) {
    contactemail_ = new ::std::string;
  }
  return contactemail_;
}
inline ::std::string* App_ExtendedInfo::release_contactemail() {
  clear_has_contactemail();
  if (contactemail_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = contactemail_;
    contactemail_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string downloadsCountText = 23;
inline bool App_ExtendedInfo::has_downloadscounttext() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void App_ExtendedInfo::set_has_downloadscounttext() {
  _has_bits_[0] |= 0x00000080u;
}
inline void App_ExtendedInfo::clear_has_downloadscounttext() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void App_ExtendedInfo::clear_downloadscounttext() {
  if (downloadscounttext_ != &::google::protobuf::internal::kEmptyString) {
    downloadscounttext_->clear();
  }
  clear_has_downloadscounttext();
}
inline const ::std::string& App_ExtendedInfo::downloadscounttext() const {
  return *downloadscounttext_;
}
inline void App_ExtendedInfo::set_downloadscounttext(const ::std::string& value) {
  set_has_downloadscounttext();
  if (downloadscounttext_ == &::google::protobuf::internal::kEmptyString) {
    downloadscounttext_ = new ::std::string;
  }
  downloadscounttext_->assign(value);
}
inline void App_ExtendedInfo::set_downloadscounttext(const char* value) {
  set_has_downloadscounttext();
  if (downloadscounttext_ == &::google::protobuf::internal::kEmptyString) {
    downloadscounttext_ = new ::std::string;
  }
  downloadscounttext_->assign(value);
}
inline void App_ExtendedInfo::set_downloadscounttext(const char* value, size_t size) {
  set_has_downloadscounttext();
  if (downloadscounttext_ == &::google::protobuf::internal::kEmptyString) {
    downloadscounttext_ = new ::std::string;
  }
  downloadscounttext_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* App_ExtendedInfo::mutable_downloadscounttext() {
  set_has_downloadscounttext();
  if (downloadscounttext_ == &::google::protobuf::internal::kEmptyString) {
    downloadscounttext_ = new ::std::string;
  }
  return downloadscounttext_;
}
inline ::std::string* App_ExtendedInfo::release_downloadscounttext() {
  clear_has_downloadscounttext();
  if (downloadscounttext_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = downloadscounttext_;
    downloadscounttext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string contactPhone = 26;
inline bool App_ExtendedInfo::has_contactphone() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void App_ExtendedInfo::set_has_contactphone() {
  _has_bits_[0] |= 0x00000100u;
}
inline void App_ExtendedInfo::clear_has_contactphone() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void App_ExtendedInfo::clear_contactphone() {
  if (contactphone_ != &::google::protobuf::internal::kEmptyString) {
    contactphone_->clear();
  }
  clear_has_contactphone();
}
inline const ::std::string& App_ExtendedInfo::contactphone() const {
  return *contactphone_;
}
inline void App_ExtendedInfo::set_contactphone(const ::std::string& value) {
  set_has_contactphone();
  if (contactphone_ == &::google::protobuf::internal::kEmptyString) {
    contactphone_ = new ::std::string;
  }
  contactphone_->assign(value);
}
inline void App_ExtendedInfo::set_contactphone(const char* value) {
  set_has_contactphone();
  if (contactphone_ == &::google::protobuf::internal::kEmptyString) {
    contactphone_ = new ::std::string;
  }
  contactphone_->assign(value);
}
inline void App_ExtendedInfo::set_contactphone(const char* value, size_t size) {
  set_has_contactphone();
  if (contactphone_ == &::google::protobuf::internal::kEmptyString) {
    contactphone_ = new ::std::string;
  }
  contactphone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* App_ExtendedInfo::mutable_contactphone() {
  set_has_contactphone();
  if (contactphone_ == &::google::protobuf::internal::kEmptyString) {
    contactphone_ = new ::std::string;
  }
  return contactphone_;
}
inline ::std::string* App_ExtendedInfo::release_contactphone() {
  clear_has_contactphone();
  if (contactphone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = contactphone_;
    contactphone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string contactWebsite = 27;
inline bool App_ExtendedInfo::has_contactwebsite() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void App_ExtendedInfo::set_has_contactwebsite() {
  _has_bits_[0] |= 0x00000200u;
}
inline void App_ExtendedInfo::clear_has_contactwebsite() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void App_ExtendedInfo::clear_contactwebsite() {
  if (contactwebsite_ != &::google::protobuf::internal::kEmptyString) {
    contactwebsite_->clear();
  }
  clear_has_contactwebsite();
}
inline const ::std::string& App_ExtendedInfo::contactwebsite() const {
  return *contactwebsite_;
}
inline void App_ExtendedInfo::set_contactwebsite(const ::std::string& value) {
  set_has_contactwebsite();
  if (contactwebsite_ == &::google::protobuf::internal::kEmptyString) {
    contactwebsite_ = new ::std::string;
  }
  contactwebsite_->assign(value);
}
inline void App_ExtendedInfo::set_contactwebsite(const char* value) {
  set_has_contactwebsite();
  if (contactwebsite_ == &::google::protobuf::internal::kEmptyString) {
    contactwebsite_ = new ::std::string;
  }
  contactwebsite_->assign(value);
}
inline void App_ExtendedInfo::set_contactwebsite(const char* value, size_t size) {
  set_has_contactwebsite();
  if (contactwebsite_ == &::google::protobuf::internal::kEmptyString) {
    contactwebsite_ = new ::std::string;
  }
  contactwebsite_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* App_ExtendedInfo::mutable_contactwebsite() {
  set_has_contactwebsite();
  if (contactwebsite_ == &::google::protobuf::internal::kEmptyString) {
    contactwebsite_ = new ::std::string;
  }
  return contactwebsite_;
}
inline ::std::string* App_ExtendedInfo::release_contactwebsite() {
  clear_has_contactwebsite();
  if (contactwebsite_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = contactwebsite_;
    contactwebsite_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 screenshotsCount = 30;
inline bool App_ExtendedInfo::has_screenshotscount() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void App_ExtendedInfo::set_has_screenshotscount() {
  _has_bits_[0] |= 0x00000400u;
}
inline void App_ExtendedInfo::clear_has_screenshotscount() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void App_ExtendedInfo::clear_screenshotscount() {
  screenshotscount_ = 0;
  clear_has_screenshotscount();
}
inline ::google::protobuf::int32 App_ExtendedInfo::screenshotscount() const {
  return screenshotscount_;
}
inline void App_ExtendedInfo::set_screenshotscount(::google::protobuf::int32 value) {
  set_has_screenshotscount();
  screenshotscount_ = value;
}

// optional string promoText = 31;
inline bool App_ExtendedInfo::has_promotext() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void App_ExtendedInfo::set_has_promotext() {
  _has_bits_[0] |= 0x00000800u;
}
inline void App_ExtendedInfo::clear_has_promotext() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void App_ExtendedInfo::clear_promotext() {
  if (promotext_ != &::google::protobuf::internal::kEmptyString) {
    promotext_->clear();
  }
  clear_has_promotext();
}
inline const ::std::string& App_ExtendedInfo::promotext() const {
  return *promotext_;
}
inline void App_ExtendedInfo::set_promotext(const ::std::string& value) {
  set_has_promotext();
  if (promotext_ == &::google::protobuf::internal::kEmptyString) {
    promotext_ = new ::std::string;
  }
  promotext_->assign(value);
}
inline void App_ExtendedInfo::set_promotext(const char* value) {
  set_has_promotext();
  if (promotext_ == &::google::protobuf::internal::kEmptyString) {
    promotext_ = new ::std::string;
  }
  promotext_->assign(value);
}
inline void App_ExtendedInfo::set_promotext(const char* value, size_t size) {
  set_has_promotext();
  if (promotext_ == &::google::protobuf::internal::kEmptyString) {
    promotext_ = new ::std::string;
  }
  promotext_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* App_ExtendedInfo::mutable_promotext() {
  set_has_promotext();
  if (promotext_ == &::google::protobuf::internal::kEmptyString) {
    promotext_ = new ::std::string;
  }
  return promotext_;
}
inline ::std::string* App_ExtendedInfo::release_promotext() {
  clear_has_promotext();
  if (promotext_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = promotext_;
    promotext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string recentChanges = 38;
inline bool App_ExtendedInfo::has_recentchanges() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void App_ExtendedInfo::set_has_recentchanges() {
  _has_bits_[0] |= 0x00001000u;
}
inline void App_ExtendedInfo::clear_has_recentchanges() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void App_ExtendedInfo::clear_recentchanges() {
  if (recentchanges_ != &::google::protobuf::internal::kEmptyString) {
    recentchanges_->clear();
  }
  clear_has_recentchanges();
}
inline const ::std::string& App_ExtendedInfo::recentchanges() const {
  return *recentchanges_;
}
inline void App_ExtendedInfo::set_recentchanges(const ::std::string& value) {
  set_has_recentchanges();
  if (recentchanges_ == &::google::protobuf::internal::kEmptyString) {
    recentchanges_ = new ::std::string;
  }
  recentchanges_->assign(value);
}
inline void App_ExtendedInfo::set_recentchanges(const char* value) {
  set_has_recentchanges();
  if (recentchanges_ == &::google::protobuf::internal::kEmptyString) {
    recentchanges_ = new ::std::string;
  }
  recentchanges_->assign(value);
}
inline void App_ExtendedInfo::set_recentchanges(const char* value, size_t size) {
  set_has_recentchanges();
  if (recentchanges_ == &::google::protobuf::internal::kEmptyString) {
    recentchanges_ = new ::std::string;
  }
  recentchanges_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* App_ExtendedInfo::mutable_recentchanges() {
  set_has_recentchanges();
  if (recentchanges_ == &::google::protobuf::internal::kEmptyString) {
    recentchanges_ = new ::std::string;
  }
  return recentchanges_;
}
inline ::std::string* App_ExtendedInfo::release_recentchanges() {
  clear_has_recentchanges();
  if (recentchanges_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = recentchanges_;
    recentchanges_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string promotionalVideo = 43;
inline bool App_ExtendedInfo::has_promotionalvideo() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void App_ExtendedInfo::set_has_promotionalvideo() {
  _has_bits_[0] |= 0x00002000u;
}
inline void App_ExtendedInfo::clear_has_promotionalvideo() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void App_ExtendedInfo::clear_promotionalvideo() {
  if (promotionalvideo_ != &::google::protobuf::internal::kEmptyString) {
    promotionalvideo_->clear();
  }
  clear_has_promotionalvideo();
}
inline const ::std::string& App_ExtendedInfo::promotionalvideo() const {
  return *promotionalvideo_;
}
inline void App_ExtendedInfo::set_promotionalvideo(const ::std::string& value) {
  set_has_promotionalvideo();
  if (promotionalvideo_ == &::google::protobuf::internal::kEmptyString) {
    promotionalvideo_ = new ::std::string;
  }
  promotionalvideo_->assign(value);
}
inline void App_ExtendedInfo::set_promotionalvideo(const char* value) {
  set_has_promotionalvideo();
  if (promotionalvideo_ == &::google::protobuf::internal::kEmptyString) {
    promotionalvideo_ = new ::std::string;
  }
  promotionalvideo_->assign(value);
}
inline void App_ExtendedInfo::set_promotionalvideo(const char* value, size_t size) {
  set_has_promotionalvideo();
  if (promotionalvideo_ == &::google::protobuf::internal::kEmptyString) {
    promotionalvideo_ = new ::std::string;
  }
  promotionalvideo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* App_ExtendedInfo::mutable_promotionalvideo() {
  set_has_promotionalvideo();
  if (promotionalvideo_ == &::google::protobuf::internal::kEmptyString) {
    promotionalvideo_ = new ::std::string;
  }
  return promotionalvideo_;
}
inline ::std::string* App_ExtendedInfo::release_promotionalvideo() {
  clear_has_promotionalvideo();
  if (promotionalvideo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = promotionalvideo_;
    promotionalvideo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// App

// optional string id = 1;
inline bool App::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void App::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void App::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void App::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& App::id() const {
  return *id_;
}
inline void App::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void App::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void App::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* App::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* App::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string title = 2;
inline bool App::has_title() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void App::set_has_title() {
  _has_bits_[0] |= 0x00000002u;
}
inline void App::clear_has_title() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void App::clear_title() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& App::title() const {
  return *title_;
}
inline void App::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void App::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void App::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* App::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* App::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .AppType appType = 3 [default = NONE];
inline bool App::has_apptype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void App::set_has_apptype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void App::clear_has_apptype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void App::clear_apptype() {
  apptype_ = 0;
  clear_has_apptype();
}
inline AppType App::apptype() const {
  return static_cast< AppType >(apptype_);
}
inline void App::set_apptype(AppType value) {
  GOOGLE_DCHECK(AppType_IsValid(value));
  set_has_apptype();
  apptype_ = value;
}

// optional string creator = 4;
inline bool App::has_creator() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void App::set_has_creator() {
  _has_bits_[0] |= 0x00000008u;
}
inline void App::clear_has_creator() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void App::clear_creator() {
  if (creator_ != &::google::protobuf::internal::kEmptyString) {
    creator_->clear();
  }
  clear_has_creator();
}
inline const ::std::string& App::creator() const {
  return *creator_;
}
inline void App::set_creator(const ::std::string& value) {
  set_has_creator();
  if (creator_ == &::google::protobuf::internal::kEmptyString) {
    creator_ = new ::std::string;
  }
  creator_->assign(value);
}
inline void App::set_creator(const char* value) {
  set_has_creator();
  if (creator_ == &::google::protobuf::internal::kEmptyString) {
    creator_ = new ::std::string;
  }
  creator_->assign(value);
}
inline void App::set_creator(const char* value, size_t size) {
  set_has_creator();
  if (creator_ == &::google::protobuf::internal::kEmptyString) {
    creator_ = new ::std::string;
  }
  creator_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* App::mutable_creator() {
  set_has_creator();
  if (creator_ == &::google::protobuf::internal::kEmptyString) {
    creator_ = new ::std::string;
  }
  return creator_;
}
inline ::std::string* App::release_creator() {
  clear_has_creator();
  if (creator_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = creator_;
    creator_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string version = 5;
inline bool App::has_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void App::set_has_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void App::clear_has_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void App::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& App::version() const {
  return *version_;
}
inline void App::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void App::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void App::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* App::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* App::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string price = 6;
inline bool App::has_price() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void App::set_has_price() {
  _has_bits_[0] |= 0x00000020u;
}
inline void App::clear_has_price() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void App::clear_price() {
  if (price_ != &::google::protobuf::internal::kEmptyString) {
    price_->clear();
  }
  clear_has_price();
}
inline const ::std::string& App::price() const {
  return *price_;
}
inline void App::set_price(const ::std::string& value) {
  set_has_price();
  if (price_ == &::google::protobuf::internal::kEmptyString) {
    price_ = new ::std::string;
  }
  price_->assign(value);
}
inline void App::set_price(const char* value) {
  set_has_price();
  if (price_ == &::google::protobuf::internal::kEmptyString) {
    price_ = new ::std::string;
  }
  price_->assign(value);
}
inline void App::set_price(const char* value, size_t size) {
  set_has_price();
  if (price_ == &::google::protobuf::internal::kEmptyString) {
    price_ = new ::std::string;
  }
  price_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* App::mutable_price() {
  set_has_price();
  if (price_ == &::google::protobuf::internal::kEmptyString) {
    price_ = new ::std::string;
  }
  return price_;
}
inline ::std::string* App::release_price() {
  clear_has_price();
  if (price_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = price_;
    price_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string rating = 7;
inline bool App::has_rating() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void App::set_has_rating() {
  _has_bits_[0] |= 0x00000040u;
}
inline void App::clear_has_rating() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void App::clear_rating() {
  if (rating_ != &::google::protobuf::internal::kEmptyString) {
    rating_->clear();
  }
  clear_has_rating();
}
inline const ::std::string& App::rating() const {
  return *rating_;
}
inline void App::set_rating(const ::std::string& value) {
  set_has_rating();
  if (rating_ == &::google::protobuf::internal::kEmptyString) {
    rating_ = new ::std::string;
  }
  rating_->assign(value);
}
inline void App::set_rating(const char* value) {
  set_has_rating();
  if (rating_ == &::google::protobuf::internal::kEmptyString) {
    rating_ = new ::std::string;
  }
  rating_->assign(value);
}
inline void App::set_rating(const char* value, size_t size) {
  set_has_rating();
  if (rating_ == &::google::protobuf::internal::kEmptyString) {
    rating_ = new ::std::string;
  }
  rating_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* App::mutable_rating() {
  set_has_rating();
  if (rating_ == &::google::protobuf::internal::kEmptyString) {
    rating_ = new ::std::string;
  }
  return rating_;
}
inline ::std::string* App::release_rating() {
  clear_has_rating();
  if (rating_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rating_;
    rating_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 ratingsCount = 8;
inline bool App::has_ratingscount() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void App::set_has_ratingscount() {
  _has_bits_[0] |= 0x00000080u;
}
inline void App::clear_has_ratingscount() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void App::clear_ratingscount() {
  ratingscount_ = 0;
  clear_has_ratingscount();
}
inline ::google::protobuf::int32 App::ratingscount() const {
  return ratingscount_;
}
inline void App::set_ratingscount(::google::protobuf::int32 value) {
  set_has_ratingscount();
  ratingscount_ = value;
}

// optional group ExtendedInfo = 12 {
inline bool App::has_extendedinfo() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void App::set_has_extendedinfo() {
  _has_bits_[0] |= 0x00000100u;
}
inline void App::clear_has_extendedinfo() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void App::clear_extendedinfo() {
  if (extendedinfo_ != NULL) extendedinfo_->::App_ExtendedInfo::Clear();
  clear_has_extendedinfo();
}
inline const ::App_ExtendedInfo& App::extendedinfo() const {
  return extendedinfo_ != NULL ? *extendedinfo_ : *default_instance_->extendedinfo_;
}
inline ::App_ExtendedInfo* App::mutable_extendedinfo() {
  set_has_extendedinfo();
  if (extendedinfo_ == NULL) extendedinfo_ = new ::App_ExtendedInfo;
  return extendedinfo_;
}
inline ::App_ExtendedInfo* App::release_extendedinfo() {
  clear_has_extendedinfo();
  ::App_ExtendedInfo* temp = extendedinfo_;
  extendedinfo_ = NULL;
  return temp;
}

// optional string creatorId = 22;
inline bool App::has_creatorid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void App::set_has_creatorid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void App::clear_has_creatorid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void App::clear_creatorid() {
  if (creatorid_ != &::google::protobuf::internal::kEmptyString) {
    creatorid_->clear();
  }
  clear_has_creatorid();
}
inline const ::std::string& App::creatorid() const {
  return *creatorid_;
}
inline void App::set_creatorid(const ::std::string& value) {
  set_has_creatorid();
  if (creatorid_ == &::google::protobuf::internal::kEmptyString) {
    creatorid_ = new ::std::string;
  }
  creatorid_->assign(value);
}
inline void App::set_creatorid(const char* value) {
  set_has_creatorid();
  if (creatorid_ == &::google::protobuf::internal::kEmptyString) {
    creatorid_ = new ::std::string;
  }
  creatorid_->assign(value);
}
inline void App::set_creatorid(const char* value, size_t size) {
  set_has_creatorid();
  if (creatorid_ == &::google::protobuf::internal::kEmptyString) {
    creatorid_ = new ::std::string;
  }
  creatorid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* App::mutable_creatorid() {
  set_has_creatorid();
  if (creatorid_ == &::google::protobuf::internal::kEmptyString) {
    creatorid_ = new ::std::string;
  }
  return creatorid_;
}
inline ::std::string* App::release_creatorid() {
  clear_has_creatorid();
  if (creatorid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = creatorid_;
    creatorid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string packageName = 24;
inline bool App::has_packagename() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void App::set_has_packagename() {
  _has_bits_[0] |= 0x00000400u;
}
inline void App::clear_has_packagename() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void App::clear_packagename() {
  if (packagename_ != &::google::protobuf::internal::kEmptyString) {
    packagename_->clear();
  }
  clear_has_packagename();
}
inline const ::std::string& App::packagename() const {
  return *packagename_;
}
inline void App::set_packagename(const ::std::string& value) {
  set_has_packagename();
  if (packagename_ == &::google::protobuf::internal::kEmptyString) {
    packagename_ = new ::std::string;
  }
  packagename_->assign(value);
}
inline void App::set_packagename(const char* value) {
  set_has_packagename();
  if (packagename_ == &::google::protobuf::internal::kEmptyString) {
    packagename_ = new ::std::string;
  }
  packagename_->assign(value);
}
inline void App::set_packagename(const char* value, size_t size) {
  set_has_packagename();
  if (packagename_ == &::google::protobuf::internal::kEmptyString) {
    packagename_ = new ::std::string;
  }
  packagename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* App::mutable_packagename() {
  set_has_packagename();
  if (packagename_ == &::google::protobuf::internal::kEmptyString) {
    packagename_ = new ::std::string;
  }
  return packagename_;
}
inline ::std::string* App::release_packagename() {
  clear_has_packagename();
  if (packagename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = packagename_;
    packagename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 versionCode = 25;
inline bool App::has_versioncode() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void App::set_has_versioncode() {
  _has_bits_[0] |= 0x00000800u;
}
inline void App::clear_has_versioncode() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void App::clear_versioncode() {
  versioncode_ = 0;
  clear_has_versioncode();
}
inline ::google::protobuf::int32 App::versioncode() const {
  return versioncode_;
}
inline void App::set_versioncode(::google::protobuf::int32 value) {
  set_has_versioncode();
  versioncode_ = value;
}

// optional string priceCurrency = 32;
inline bool App::has_pricecurrency() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void App::set_has_pricecurrency() {
  _has_bits_[0] |= 0x00001000u;
}
inline void App::clear_has_pricecurrency() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void App::clear_pricecurrency() {
  if (pricecurrency_ != &::google::protobuf::internal::kEmptyString) {
    pricecurrency_->clear();
  }
  clear_has_pricecurrency();
}
inline const ::std::string& App::pricecurrency() const {
  return *pricecurrency_;
}
inline void App::set_pricecurrency(const ::std::string& value) {
  set_has_pricecurrency();
  if (pricecurrency_ == &::google::protobuf::internal::kEmptyString) {
    pricecurrency_ = new ::std::string;
  }
  pricecurrency_->assign(value);
}
inline void App::set_pricecurrency(const char* value) {
  set_has_pricecurrency();
  if (pricecurrency_ == &::google::protobuf::internal::kEmptyString) {
    pricecurrency_ = new ::std::string;
  }
  pricecurrency_->assign(value);
}
inline void App::set_pricecurrency(const char* value, size_t size) {
  set_has_pricecurrency();
  if (pricecurrency_ == &::google::protobuf::internal::kEmptyString) {
    pricecurrency_ = new ::std::string;
  }
  pricecurrency_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* App::mutable_pricecurrency() {
  set_has_pricecurrency();
  if (pricecurrency_ == &::google::protobuf::internal::kEmptyString) {
    pricecurrency_ = new ::std::string;
  }
  return pricecurrency_;
}
inline ::std::string* App::release_pricecurrency() {
  clear_has_pricecurrency();
  if (pricecurrency_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pricecurrency_;
    pricecurrency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 priceMicros = 33;
inline bool App::has_pricemicros() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void App::set_has_pricemicros() {
  _has_bits_[0] |= 0x00002000u;
}
inline void App::clear_has_pricemicros() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void App::clear_pricemicros() {
  pricemicros_ = 0;
  clear_has_pricemicros();
}
inline ::google::protobuf::int32 App::pricemicros() const {
  return pricemicros_;
}
inline void App::set_pricemicros(::google::protobuf::int32 value) {
  set_has_pricemicros();
  pricemicros_ = value;
}

// -------------------------------------------------------------------

// Comment

// optional string text = 1;
inline bool Comment::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Comment::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Comment::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Comment::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& Comment::text() const {
  return *text_;
}
inline void Comment::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void Comment::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void Comment::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Comment::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* Comment::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 rating = 2;
inline bool Comment::has_rating() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Comment::set_has_rating() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Comment::clear_has_rating() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Comment::clear_rating() {
  rating_ = 0;
  clear_has_rating();
}
inline ::google::protobuf::int32 Comment::rating() const {
  return rating_;
}
inline void Comment::set_rating(::google::protobuf::int32 value) {
  set_has_rating();
  rating_ = value;
}

// optional string authorName = 3;
inline bool Comment::has_authorname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Comment::set_has_authorname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Comment::clear_has_authorname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Comment::clear_authorname() {
  if (authorname_ != &::google::protobuf::internal::kEmptyString) {
    authorname_->clear();
  }
  clear_has_authorname();
}
inline const ::std::string& Comment::authorname() const {
  return *authorname_;
}
inline void Comment::set_authorname(const ::std::string& value) {
  set_has_authorname();
  if (authorname_ == &::google::protobuf::internal::kEmptyString) {
    authorname_ = new ::std::string;
  }
  authorname_->assign(value);
}
inline void Comment::set_authorname(const char* value) {
  set_has_authorname();
  if (authorname_ == &::google::protobuf::internal::kEmptyString) {
    authorname_ = new ::std::string;
  }
  authorname_->assign(value);
}
inline void Comment::set_authorname(const char* value, size_t size) {
  set_has_authorname();
  if (authorname_ == &::google::protobuf::internal::kEmptyString) {
    authorname_ = new ::std::string;
  }
  authorname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Comment::mutable_authorname() {
  set_has_authorname();
  if (authorname_ == &::google::protobuf::internal::kEmptyString) {
    authorname_ = new ::std::string;
  }
  return authorname_;
}
inline ::std::string* Comment::release_authorname() {
  clear_has_authorname();
  if (authorname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = authorname_;
    authorname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint64 creationTime = 4;
inline bool Comment::has_creationtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Comment::set_has_creationtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Comment::clear_has_creationtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Comment::clear_creationtime() {
  creationtime_ = GOOGLE_ULONGLONG(0);
  clear_has_creationtime();
}
inline ::google::protobuf::uint64 Comment::creationtime() const {
  return creationtime_;
}
inline void Comment::set_creationtime(::google::protobuf::uint64 value) {
  set_has_creationtime();
  creationtime_ = value;
}

// optional string authorId = 5;
inline bool Comment::has_authorid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Comment::set_has_authorid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Comment::clear_has_authorid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Comment::clear_authorid() {
  if (authorid_ != &::google::protobuf::internal::kEmptyString) {
    authorid_->clear();
  }
  clear_has_authorid();
}
inline const ::std::string& Comment::authorid() const {
  return *authorid_;
}
inline void Comment::set_authorid(const ::std::string& value) {
  set_has_authorid();
  if (authorid_ == &::google::protobuf::internal::kEmptyString) {
    authorid_ = new ::std::string;
  }
  authorid_->assign(value);
}
inline void Comment::set_authorid(const char* value) {
  set_has_authorid();
  if (authorid_ == &::google::protobuf::internal::kEmptyString) {
    authorid_ = new ::std::string;
  }
  authorid_->assign(value);
}
inline void Comment::set_authorid(const char* value, size_t size) {
  set_has_authorid();
  if (authorid_ == &::google::protobuf::internal::kEmptyString) {
    authorid_ = new ::std::string;
  }
  authorid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Comment::mutable_authorid() {
  set_has_authorid();
  if (authorid_ == &::google::protobuf::internal::kEmptyString) {
    authorid_ = new ::std::string;
  }
  return authorid_;
}
inline ::std::string* Comment::release_authorid() {
  clear_has_authorid();
  if (authorid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = authorid_;
    authorid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// CategoriesRequest

// -------------------------------------------------------------------

// CategoriesResponse

// repeated .Category categories = 1;
inline int CategoriesResponse::categories_size() const {
  return categories_.size();
}
inline void CategoriesResponse::clear_categories() {
  categories_.Clear();
}
inline const ::Category& CategoriesResponse::categories(int index) const {
  return categories_.Get(index);
}
inline ::Category* CategoriesResponse::mutable_categories(int index) {
  return categories_.Mutable(index);
}
inline ::Category* CategoriesResponse::add_categories() {
  return categories_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Category >&
CategoriesResponse::categories() const {
  return categories_;
}
inline ::google::protobuf::RepeatedPtrField< ::Category >*
CategoriesResponse::mutable_categories() {
  return &categories_;
}

// -------------------------------------------------------------------

// SubCategoriesRequest

// optional .AppType appType = 1;
inline bool SubCategoriesRequest::has_apptype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubCategoriesRequest::set_has_apptype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubCategoriesRequest::clear_has_apptype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubCategoriesRequest::clear_apptype() {
  apptype_ = 0;
  clear_has_apptype();
}
inline AppType SubCategoriesRequest::apptype() const {
  return static_cast< AppType >(apptype_);
}
inline void SubCategoriesRequest::set_apptype(AppType value) {
  GOOGLE_DCHECK(AppType_IsValid(value));
  set_has_apptype();
  apptype_ = value;
}

// -------------------------------------------------------------------

// SubCategoriesResponse

// repeated .Category category = 1;
inline int SubCategoriesResponse::category_size() const {
  return category_.size();
}
inline void SubCategoriesResponse::clear_category() {
  category_.Clear();
}
inline const ::Category& SubCategoriesResponse::category(int index) const {
  return category_.Get(index);
}
inline ::Category* SubCategoriesResponse::mutable_category(int index) {
  return category_.Mutable(index);
}
inline ::Category* SubCategoriesResponse::add_category() {
  return category_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Category >&
SubCategoriesResponse::category() const {
  return category_;
}
inline ::google::protobuf::RepeatedPtrField< ::Category >*
SubCategoriesResponse::mutable_category() {
  return &category_;
}

// optional string subCategoryDisplay = 2;
inline bool SubCategoriesResponse::has_subcategorydisplay() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SubCategoriesResponse::set_has_subcategorydisplay() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SubCategoriesResponse::clear_has_subcategorydisplay() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SubCategoriesResponse::clear_subcategorydisplay() {
  if (subcategorydisplay_ != &::google::protobuf::internal::kEmptyString) {
    subcategorydisplay_->clear();
  }
  clear_has_subcategorydisplay();
}
inline const ::std::string& SubCategoriesResponse::subcategorydisplay() const {
  return *subcategorydisplay_;
}
inline void SubCategoriesResponse::set_subcategorydisplay(const ::std::string& value) {
  set_has_subcategorydisplay();
  if (subcategorydisplay_ == &::google::protobuf::internal::kEmptyString) {
    subcategorydisplay_ = new ::std::string;
  }
  subcategorydisplay_->assign(value);
}
inline void SubCategoriesResponse::set_subcategorydisplay(const char* value) {
  set_has_subcategorydisplay();
  if (subcategorydisplay_ == &::google::protobuf::internal::kEmptyString) {
    subcategorydisplay_ = new ::std::string;
  }
  subcategorydisplay_->assign(value);
}
inline void SubCategoriesResponse::set_subcategorydisplay(const char* value, size_t size) {
  set_has_subcategorydisplay();
  if (subcategorydisplay_ == &::google::protobuf::internal::kEmptyString) {
    subcategorydisplay_ = new ::std::string;
  }
  subcategorydisplay_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SubCategoriesResponse::mutable_subcategorydisplay() {
  set_has_subcategorydisplay();
  if (subcategorydisplay_ == &::google::protobuf::internal::kEmptyString) {
    subcategorydisplay_ = new ::std::string;
  }
  return subcategorydisplay_;
}
inline ::std::string* SubCategoriesResponse::release_subcategorydisplay() {
  clear_has_subcategorydisplay();
  if (subcategorydisplay_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subcategorydisplay_;
    subcategorydisplay_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 subCategoryId = 3;
inline bool SubCategoriesResponse::has_subcategoryid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SubCategoriesResponse::set_has_subcategoryid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SubCategoriesResponse::clear_has_subcategoryid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SubCategoriesResponse::clear_subcategoryid() {
  subcategoryid_ = 0;
  clear_has_subcategoryid();
}
inline ::google::protobuf::int32 SubCategoriesResponse::subcategoryid() const {
  return subcategoryid_;
}
inline void SubCategoriesResponse::set_subcategoryid(::google::protobuf::int32 value) {
  set_has_subcategoryid();
  subcategoryid_ = value;
}

// -------------------------------------------------------------------

// RequestContext

// required string authSubToken = 1;
inline bool RequestContext::has_authsubtoken() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestContext::set_has_authsubtoken() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestContext::clear_has_authsubtoken() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestContext::clear_authsubtoken() {
  if (authsubtoken_ != &::google::protobuf::internal::kEmptyString) {
    authsubtoken_->clear();
  }
  clear_has_authsubtoken();
}
inline const ::std::string& RequestContext::authsubtoken() const {
  return *authsubtoken_;
}
inline void RequestContext::set_authsubtoken(const ::std::string& value) {
  set_has_authsubtoken();
  if (authsubtoken_ == &::google::protobuf::internal::kEmptyString) {
    authsubtoken_ = new ::std::string;
  }
  authsubtoken_->assign(value);
}
inline void RequestContext::set_authsubtoken(const char* value) {
  set_has_authsubtoken();
  if (authsubtoken_ == &::google::protobuf::internal::kEmptyString) {
    authsubtoken_ = new ::std::string;
  }
  authsubtoken_->assign(value);
}
inline void RequestContext::set_authsubtoken(const char* value, size_t size) {
  set_has_authsubtoken();
  if (authsubtoken_ == &::google::protobuf::internal::kEmptyString) {
    authsubtoken_ = new ::std::string;
  }
  authsubtoken_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestContext::mutable_authsubtoken() {
  set_has_authsubtoken();
  if (authsubtoken_ == &::google::protobuf::internal::kEmptyString) {
    authsubtoken_ = new ::std::string;
  }
  return authsubtoken_;
}
inline ::std::string* RequestContext::release_authsubtoken() {
  clear_has_authsubtoken();
  if (authsubtoken_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = authsubtoken_;
    authsubtoken_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bool isSecure = 2;
inline bool RequestContext::has_issecure() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestContext::set_has_issecure() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestContext::clear_has_issecure() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestContext::clear_issecure() {
  issecure_ = false;
  clear_has_issecure();
}
inline bool RequestContext::issecure() const {
  return issecure_;
}
inline void RequestContext::set_issecure(bool value) {
  set_has_issecure();
  issecure_ = value;
}

// required int32 version = 3;
inline bool RequestContext::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestContext::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestContext::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestContext::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 RequestContext::version() const {
  return version_;
}
inline void RequestContext::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
}

// required string androidId = 4;
inline bool RequestContext::has_androidid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestContext::set_has_androidid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestContext::clear_has_androidid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestContext::clear_androidid() {
  if (androidid_ != &::google::protobuf::internal::kEmptyString) {
    androidid_->clear();
  }
  clear_has_androidid();
}
inline const ::std::string& RequestContext::androidid() const {
  return *androidid_;
}
inline void RequestContext::set_androidid(const ::std::string& value) {
  set_has_androidid();
  if (androidid_ == &::google::protobuf::internal::kEmptyString) {
    androidid_ = new ::std::string;
  }
  androidid_->assign(value);
}
inline void RequestContext::set_androidid(const char* value) {
  set_has_androidid();
  if (androidid_ == &::google::protobuf::internal::kEmptyString) {
    androidid_ = new ::std::string;
  }
  androidid_->assign(value);
}
inline void RequestContext::set_androidid(const char* value, size_t size) {
  set_has_androidid();
  if (androidid_ == &::google::protobuf::internal::kEmptyString) {
    androidid_ = new ::std::string;
  }
  androidid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestContext::mutable_androidid() {
  set_has_androidid();
  if (androidid_ == &::google::protobuf::internal::kEmptyString) {
    androidid_ = new ::std::string;
  }
  return androidid_;
}
inline ::std::string* RequestContext::release_androidid() {
  clear_has_androidid();
  if (androidid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = androidid_;
    androidid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string deviceAndSdkVersion = 5;
inline bool RequestContext::has_deviceandsdkversion() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestContext::set_has_deviceandsdkversion() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestContext::clear_has_deviceandsdkversion() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestContext::clear_deviceandsdkversion() {
  if (deviceandsdkversion_ != &::google::protobuf::internal::kEmptyString) {
    deviceandsdkversion_->clear();
  }
  clear_has_deviceandsdkversion();
}
inline const ::std::string& RequestContext::deviceandsdkversion() const {
  return *deviceandsdkversion_;
}
inline void RequestContext::set_deviceandsdkversion(const ::std::string& value) {
  set_has_deviceandsdkversion();
  if (deviceandsdkversion_ == &::google::protobuf::internal::kEmptyString) {
    deviceandsdkversion_ = new ::std::string;
  }
  deviceandsdkversion_->assign(value);
}
inline void RequestContext::set_deviceandsdkversion(const char* value) {
  set_has_deviceandsdkversion();
  if (deviceandsdkversion_ == &::google::protobuf::internal::kEmptyString) {
    deviceandsdkversion_ = new ::std::string;
  }
  deviceandsdkversion_->assign(value);
}
inline void RequestContext::set_deviceandsdkversion(const char* value, size_t size) {
  set_has_deviceandsdkversion();
  if (deviceandsdkversion_ == &::google::protobuf::internal::kEmptyString) {
    deviceandsdkversion_ = new ::std::string;
  }
  deviceandsdkversion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestContext::mutable_deviceandsdkversion() {
  set_has_deviceandsdkversion();
  if (deviceandsdkversion_ == &::google::protobuf::internal::kEmptyString) {
    deviceandsdkversion_ = new ::std::string;
  }
  return deviceandsdkversion_;
}
inline ::std::string* RequestContext::release_deviceandsdkversion() {
  clear_has_deviceandsdkversion();
  if (deviceandsdkversion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deviceandsdkversion_;
    deviceandsdkversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string userLanguage = 6;
inline bool RequestContext::has_userlanguage() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RequestContext::set_has_userlanguage() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RequestContext::clear_has_userlanguage() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RequestContext::clear_userlanguage() {
  if (userlanguage_ != &::google::protobuf::internal::kEmptyString) {
    userlanguage_->clear();
  }
  clear_has_userlanguage();
}
inline const ::std::string& RequestContext::userlanguage() const {
  return *userlanguage_;
}
inline void RequestContext::set_userlanguage(const ::std::string& value) {
  set_has_userlanguage();
  if (userlanguage_ == &::google::protobuf::internal::kEmptyString) {
    userlanguage_ = new ::std::string;
  }
  userlanguage_->assign(value);
}
inline void RequestContext::set_userlanguage(const char* value) {
  set_has_userlanguage();
  if (userlanguage_ == &::google::protobuf::internal::kEmptyString) {
    userlanguage_ = new ::std::string;
  }
  userlanguage_->assign(value);
}
inline void RequestContext::set_userlanguage(const char* value, size_t size) {
  set_has_userlanguage();
  if (userlanguage_ == &::google::protobuf::internal::kEmptyString) {
    userlanguage_ = new ::std::string;
  }
  userlanguage_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestContext::mutable_userlanguage() {
  set_has_userlanguage();
  if (userlanguage_ == &::google::protobuf::internal::kEmptyString) {
    userlanguage_ = new ::std::string;
  }
  return userlanguage_;
}
inline ::std::string* RequestContext::release_userlanguage() {
  clear_has_userlanguage();
  if (userlanguage_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userlanguage_;
    userlanguage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string userCountry = 7;
inline bool RequestContext::has_usercountry() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RequestContext::set_has_usercountry() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RequestContext::clear_has_usercountry() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RequestContext::clear_usercountry() {
  if (usercountry_ != &::google::protobuf::internal::kEmptyString) {
    usercountry_->clear();
  }
  clear_has_usercountry();
}
inline const ::std::string& RequestContext::usercountry() const {
  return *usercountry_;
}
inline void RequestContext::set_usercountry(const ::std::string& value) {
  set_has_usercountry();
  if (usercountry_ == &::google::protobuf::internal::kEmptyString) {
    usercountry_ = new ::std::string;
  }
  usercountry_->assign(value);
}
inline void RequestContext::set_usercountry(const char* value) {
  set_has_usercountry();
  if (usercountry_ == &::google::protobuf::internal::kEmptyString) {
    usercountry_ = new ::std::string;
  }
  usercountry_->assign(value);
}
inline void RequestContext::set_usercountry(const char* value, size_t size) {
  set_has_usercountry();
  if (usercountry_ == &::google::protobuf::internal::kEmptyString) {
    usercountry_ = new ::std::string;
  }
  usercountry_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestContext::mutable_usercountry() {
  set_has_usercountry();
  if (usercountry_ == &::google::protobuf::internal::kEmptyString) {
    usercountry_ = new ::std::string;
  }
  return usercountry_;
}
inline ::std::string* RequestContext::release_usercountry() {
  clear_has_usercountry();
  if (usercountry_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = usercountry_;
    usercountry_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string operatorAlpha = 8;
inline bool RequestContext::has_operatoralpha() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RequestContext::set_has_operatoralpha() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RequestContext::clear_has_operatoralpha() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RequestContext::clear_operatoralpha() {
  if (operatoralpha_ != &::google::protobuf::internal::kEmptyString) {
    operatoralpha_->clear();
  }
  clear_has_operatoralpha();
}
inline const ::std::string& RequestContext::operatoralpha() const {
  return *operatoralpha_;
}
inline void RequestContext::set_operatoralpha(const ::std::string& value) {
  set_has_operatoralpha();
  if (operatoralpha_ == &::google::protobuf::internal::kEmptyString) {
    operatoralpha_ = new ::std::string;
  }
  operatoralpha_->assign(value);
}
inline void RequestContext::set_operatoralpha(const char* value) {
  set_has_operatoralpha();
  if (operatoralpha_ == &::google::protobuf::internal::kEmptyString) {
    operatoralpha_ = new ::std::string;
  }
  operatoralpha_->assign(value);
}
inline void RequestContext::set_operatoralpha(const char* value, size_t size) {
  set_has_operatoralpha();
  if (operatoralpha_ == &::google::protobuf::internal::kEmptyString) {
    operatoralpha_ = new ::std::string;
  }
  operatoralpha_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestContext::mutable_operatoralpha() {
  set_has_operatoralpha();
  if (operatoralpha_ == &::google::protobuf::internal::kEmptyString) {
    operatoralpha_ = new ::std::string;
  }
  return operatoralpha_;
}
inline ::std::string* RequestContext::release_operatoralpha() {
  clear_has_operatoralpha();
  if (operatoralpha_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = operatoralpha_;
    operatoralpha_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string simOperatorAlpha = 9;
inline bool RequestContext::has_simoperatoralpha() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RequestContext::set_has_simoperatoralpha() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RequestContext::clear_has_simoperatoralpha() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RequestContext::clear_simoperatoralpha() {
  if (simoperatoralpha_ != &::google::protobuf::internal::kEmptyString) {
    simoperatoralpha_->clear();
  }
  clear_has_simoperatoralpha();
}
inline const ::std::string& RequestContext::simoperatoralpha() const {
  return *simoperatoralpha_;
}
inline void RequestContext::set_simoperatoralpha(const ::std::string& value) {
  set_has_simoperatoralpha();
  if (simoperatoralpha_ == &::google::protobuf::internal::kEmptyString) {
    simoperatoralpha_ = new ::std::string;
  }
  simoperatoralpha_->assign(value);
}
inline void RequestContext::set_simoperatoralpha(const char* value) {
  set_has_simoperatoralpha();
  if (simoperatoralpha_ == &::google::protobuf::internal::kEmptyString) {
    simoperatoralpha_ = new ::std::string;
  }
  simoperatoralpha_->assign(value);
}
inline void RequestContext::set_simoperatoralpha(const char* value, size_t size) {
  set_has_simoperatoralpha();
  if (simoperatoralpha_ == &::google::protobuf::internal::kEmptyString) {
    simoperatoralpha_ = new ::std::string;
  }
  simoperatoralpha_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestContext::mutable_simoperatoralpha() {
  set_has_simoperatoralpha();
  if (simoperatoralpha_ == &::google::protobuf::internal::kEmptyString) {
    simoperatoralpha_ = new ::std::string;
  }
  return simoperatoralpha_;
}
inline ::std::string* RequestContext::release_simoperatoralpha() {
  clear_has_simoperatoralpha();
  if (simoperatoralpha_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = simoperatoralpha_;
    simoperatoralpha_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string operatorNumeric = 10;
inline bool RequestContext::has_operatornumeric() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RequestContext::set_has_operatornumeric() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RequestContext::clear_has_operatornumeric() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RequestContext::clear_operatornumeric() {
  if (operatornumeric_ != &::google::protobuf::internal::kEmptyString) {
    operatornumeric_->clear();
  }
  clear_has_operatornumeric();
}
inline const ::std::string& RequestContext::operatornumeric() const {
  return *operatornumeric_;
}
inline void RequestContext::set_operatornumeric(const ::std::string& value) {
  set_has_operatornumeric();
  if (operatornumeric_ == &::google::protobuf::internal::kEmptyString) {
    operatornumeric_ = new ::std::string;
  }
  operatornumeric_->assign(value);
}
inline void RequestContext::set_operatornumeric(const char* value) {
  set_has_operatornumeric();
  if (operatornumeric_ == &::google::protobuf::internal::kEmptyString) {
    operatornumeric_ = new ::std::string;
  }
  operatornumeric_->assign(value);
}
inline void RequestContext::set_operatornumeric(const char* value, size_t size) {
  set_has_operatornumeric();
  if (operatornumeric_ == &::google::protobuf::internal::kEmptyString) {
    operatornumeric_ = new ::std::string;
  }
  operatornumeric_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestContext::mutable_operatornumeric() {
  set_has_operatornumeric();
  if (operatornumeric_ == &::google::protobuf::internal::kEmptyString) {
    operatornumeric_ = new ::std::string;
  }
  return operatornumeric_;
}
inline ::std::string* RequestContext::release_operatornumeric() {
  clear_has_operatornumeric();
  if (operatornumeric_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = operatornumeric_;
    operatornumeric_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string simOperatorNumeric = 11;
inline bool RequestContext::has_simoperatornumeric() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RequestContext::set_has_simoperatornumeric() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RequestContext::clear_has_simoperatornumeric() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RequestContext::clear_simoperatornumeric() {
  if (simoperatornumeric_ != &::google::protobuf::internal::kEmptyString) {
    simoperatornumeric_->clear();
  }
  clear_has_simoperatornumeric();
}
inline const ::std::string& RequestContext::simoperatornumeric() const {
  return *simoperatornumeric_;
}
inline void RequestContext::set_simoperatornumeric(const ::std::string& value) {
  set_has_simoperatornumeric();
  if (simoperatornumeric_ == &::google::protobuf::internal::kEmptyString) {
    simoperatornumeric_ = new ::std::string;
  }
  simoperatornumeric_->assign(value);
}
inline void RequestContext::set_simoperatornumeric(const char* value) {
  set_has_simoperatornumeric();
  if (simoperatornumeric_ == &::google::protobuf::internal::kEmptyString) {
    simoperatornumeric_ = new ::std::string;
  }
  simoperatornumeric_->assign(value);
}
inline void RequestContext::set_simoperatornumeric(const char* value, size_t size) {
  set_has_simoperatornumeric();
  if (simoperatornumeric_ == &::google::protobuf::internal::kEmptyString) {
    simoperatornumeric_ = new ::std::string;
  }
  simoperatornumeric_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestContext::mutable_simoperatornumeric() {
  set_has_simoperatornumeric();
  if (simoperatornumeric_ == &::google::protobuf::internal::kEmptyString) {
    simoperatornumeric_ = new ::std::string;
  }
  return simoperatornumeric_;
}
inline ::std::string* RequestContext::release_simoperatornumeric() {
  clear_has_simoperatornumeric();
  if (simoperatornumeric_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = simoperatornumeric_;
    simoperatornumeric_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetImageRequest

// optional string appId = 1;
inline bool GetImageRequest::has_appid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetImageRequest::set_has_appid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetImageRequest::clear_has_appid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetImageRequest::clear_appid() {
  if (appid_ != &::google::protobuf::internal::kEmptyString) {
    appid_->clear();
  }
  clear_has_appid();
}
inline const ::std::string& GetImageRequest::appid() const {
  return *appid_;
}
inline void GetImageRequest::set_appid(const ::std::string& value) {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    appid_ = new ::std::string;
  }
  appid_->assign(value);
}
inline void GetImageRequest::set_appid(const char* value) {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    appid_ = new ::std::string;
  }
  appid_->assign(value);
}
inline void GetImageRequest::set_appid(const char* value, size_t size) {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    appid_ = new ::std::string;
  }
  appid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetImageRequest::mutable_appid() {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    appid_ = new ::std::string;
  }
  return appid_;
}
inline ::std::string* GetImageRequest::release_appid() {
  clear_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = appid_;
    appid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .GetImageRequest.AppImageUsage imageUsage = 3;
inline bool GetImageRequest::has_imageusage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetImageRequest::set_has_imageusage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetImageRequest::clear_has_imageusage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetImageRequest::clear_imageusage() {
  imageusage_ = 0;
  clear_has_imageusage();
}
inline ::GetImageRequest_AppImageUsage GetImageRequest::imageusage() const {
  return static_cast< ::GetImageRequest_AppImageUsage >(imageusage_);
}
inline void GetImageRequest::set_imageusage(::GetImageRequest_AppImageUsage value) {
  GOOGLE_DCHECK(::GetImageRequest_AppImageUsage_IsValid(value));
  set_has_imageusage();
  imageusage_ = value;
}

// optional string imageId = 4;
inline bool GetImageRequest::has_imageid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetImageRequest::set_has_imageid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetImageRequest::clear_has_imageid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetImageRequest::clear_imageid() {
  if (imageid_ != &::google::protobuf::internal::kEmptyString) {
    imageid_->clear();
  }
  clear_has_imageid();
}
inline const ::std::string& GetImageRequest::imageid() const {
  return *imageid_;
}
inline void GetImageRequest::set_imageid(const ::std::string& value) {
  set_has_imageid();
  if (imageid_ == &::google::protobuf::internal::kEmptyString) {
    imageid_ = new ::std::string;
  }
  imageid_->assign(value);
}
inline void GetImageRequest::set_imageid(const char* value) {
  set_has_imageid();
  if (imageid_ == &::google::protobuf::internal::kEmptyString) {
    imageid_ = new ::std::string;
  }
  imageid_->assign(value);
}
inline void GetImageRequest::set_imageid(const char* value, size_t size) {
  set_has_imageid();
  if (imageid_ == &::google::protobuf::internal::kEmptyString) {
    imageid_ = new ::std::string;
  }
  imageid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetImageRequest::mutable_imageid() {
  set_has_imageid();
  if (imageid_ == &::google::protobuf::internal::kEmptyString) {
    imageid_ = new ::std::string;
  }
  return imageid_;
}
inline ::std::string* GetImageRequest::release_imageid() {
  clear_has_imageid();
  if (imageid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = imageid_;
    imageid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetAssetRequest

// required string assetId = 1;
inline bool GetAssetRequest::has_assetid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetAssetRequest::set_has_assetid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetAssetRequest::clear_has_assetid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetAssetRequest::clear_assetid() {
  if (assetid_ != &::google::protobuf::internal::kEmptyString) {
    assetid_->clear();
  }
  clear_has_assetid();
}
inline const ::std::string& GetAssetRequest::assetid() const {
  return *assetid_;
}
inline void GetAssetRequest::set_assetid(const ::std::string& value) {
  set_has_assetid();
  if (assetid_ == &::google::protobuf::internal::kEmptyString) {
    assetid_ = new ::std::string;
  }
  assetid_->assign(value);
}
inline void GetAssetRequest::set_assetid(const char* value) {
  set_has_assetid();
  if (assetid_ == &::google::protobuf::internal::kEmptyString) {
    assetid_ = new ::std::string;
  }
  assetid_->assign(value);
}
inline void GetAssetRequest::set_assetid(const char* value, size_t size) {
  set_has_assetid();
  if (assetid_ == &::google::protobuf::internal::kEmptyString) {
    assetid_ = new ::std::string;
  }
  assetid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetAssetRequest::mutable_assetid() {
  set_has_assetid();
  if (assetid_ == &::google::protobuf::internal::kEmptyString) {
    assetid_ = new ::std::string;
  }
  return assetid_;
}
inline ::std::string* GetAssetRequest::release_assetid() {
  clear_has_assetid();
  if (assetid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = assetid_;
    assetid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string directDownloadKey = 2;
inline bool GetAssetRequest::has_directdownloadkey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetAssetRequest::set_has_directdownloadkey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetAssetRequest::clear_has_directdownloadkey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetAssetRequest::clear_directdownloadkey() {
  if (directdownloadkey_ != &::google::protobuf::internal::kEmptyString) {
    directdownloadkey_->clear();
  }
  clear_has_directdownloadkey();
}
inline const ::std::string& GetAssetRequest::directdownloadkey() const {
  return *directdownloadkey_;
}
inline void GetAssetRequest::set_directdownloadkey(const ::std::string& value) {
  set_has_directdownloadkey();
  if (directdownloadkey_ == &::google::protobuf::internal::kEmptyString) {
    directdownloadkey_ = new ::std::string;
  }
  directdownloadkey_->assign(value);
}
inline void GetAssetRequest::set_directdownloadkey(const char* value) {
  set_has_directdownloadkey();
  if (directdownloadkey_ == &::google::protobuf::internal::kEmptyString) {
    directdownloadkey_ = new ::std::string;
  }
  directdownloadkey_->assign(value);
}
inline void GetAssetRequest::set_directdownloadkey(const char* value, size_t size) {
  set_has_directdownloadkey();
  if (directdownloadkey_ == &::google::protobuf::internal::kEmptyString) {
    directdownloadkey_ = new ::std::string;
  }
  directdownloadkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetAssetRequest::mutable_directdownloadkey() {
  set_has_directdownloadkey();
  if (directdownloadkey_ == &::google::protobuf::internal::kEmptyString) {
    directdownloadkey_ = new ::std::string;
  }
  return directdownloadkey_;
}
inline ::std::string* GetAssetRequest::release_directdownloadkey() {
  clear_has_directdownloadkey();
  if (directdownloadkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = directdownloadkey_;
    directdownloadkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetImageResponse

// optional bytes imageData = 1;
inline bool GetImageResponse::has_imagedata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetImageResponse::set_has_imagedata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetImageResponse::clear_has_imagedata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetImageResponse::clear_imagedata() {
  if (imagedata_ != &::google::protobuf::internal::kEmptyString) {
    imagedata_->clear();
  }
  clear_has_imagedata();
}
inline const ::std::string& GetImageResponse::imagedata() const {
  return *imagedata_;
}
inline void GetImageResponse::set_imagedata(const ::std::string& value) {
  set_has_imagedata();
  if (imagedata_ == &::google::protobuf::internal::kEmptyString) {
    imagedata_ = new ::std::string;
  }
  imagedata_->assign(value);
}
inline void GetImageResponse::set_imagedata(const char* value) {
  set_has_imagedata();
  if (imagedata_ == &::google::protobuf::internal::kEmptyString) {
    imagedata_ = new ::std::string;
  }
  imagedata_->assign(value);
}
inline void GetImageResponse::set_imagedata(const void* value, size_t size) {
  set_has_imagedata();
  if (imagedata_ == &::google::protobuf::internal::kEmptyString) {
    imagedata_ = new ::std::string;
  }
  imagedata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetImageResponse::mutable_imagedata() {
  set_has_imagedata();
  if (imagedata_ == &::google::protobuf::internal::kEmptyString) {
    imagedata_ = new ::std::string;
  }
  return imagedata_;
}
inline ::std::string* GetImageResponse::release_imagedata() {
  clear_has_imagedata();
  if (imagedata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = imagedata_;
    imagedata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetAssetResponse_InstallAsset

// optional string assetId = 2;
inline bool GetAssetResponse_InstallAsset::has_assetid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetAssetResponse_InstallAsset::set_has_assetid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetAssetResponse_InstallAsset::clear_has_assetid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetAssetResponse_InstallAsset::clear_assetid() {
  if (assetid_ != &::google::protobuf::internal::kEmptyString) {
    assetid_->clear();
  }
  clear_has_assetid();
}
inline const ::std::string& GetAssetResponse_InstallAsset::assetid() const {
  return *assetid_;
}
inline void GetAssetResponse_InstallAsset::set_assetid(const ::std::string& value) {
  set_has_assetid();
  if (assetid_ == &::google::protobuf::internal::kEmptyString) {
    assetid_ = new ::std::string;
  }
  assetid_->assign(value);
}
inline void GetAssetResponse_InstallAsset::set_assetid(const char* value) {
  set_has_assetid();
  if (assetid_ == &::google::protobuf::internal::kEmptyString) {
    assetid_ = new ::std::string;
  }
  assetid_->assign(value);
}
inline void GetAssetResponse_InstallAsset::set_assetid(const char* value, size_t size) {
  set_has_assetid();
  if (assetid_ == &::google::protobuf::internal::kEmptyString) {
    assetid_ = new ::std::string;
  }
  assetid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetAssetResponse_InstallAsset::mutable_assetid() {
  set_has_assetid();
  if (assetid_ == &::google::protobuf::internal::kEmptyString) {
    assetid_ = new ::std::string;
  }
  return assetid_;
}
inline ::std::string* GetAssetResponse_InstallAsset::release_assetid() {
  clear_has_assetid();
  if (assetid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = assetid_;
    assetid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string assetName = 3;
inline bool GetAssetResponse_InstallAsset::has_assetname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetAssetResponse_InstallAsset::set_has_assetname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetAssetResponse_InstallAsset::clear_has_assetname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetAssetResponse_InstallAsset::clear_assetname() {
  if (assetname_ != &::google::protobuf::internal::kEmptyString) {
    assetname_->clear();
  }
  clear_has_assetname();
}
inline const ::std::string& GetAssetResponse_InstallAsset::assetname() const {
  return *assetname_;
}
inline void GetAssetResponse_InstallAsset::set_assetname(const ::std::string& value) {
  set_has_assetname();
  if (assetname_ == &::google::protobuf::internal::kEmptyString) {
    assetname_ = new ::std::string;
  }
  assetname_->assign(value);
}
inline void GetAssetResponse_InstallAsset::set_assetname(const char* value) {
  set_has_assetname();
  if (assetname_ == &::google::protobuf::internal::kEmptyString) {
    assetname_ = new ::std::string;
  }
  assetname_->assign(value);
}
inline void GetAssetResponse_InstallAsset::set_assetname(const char* value, size_t size) {
  set_has_assetname();
  if (assetname_ == &::google::protobuf::internal::kEmptyString) {
    assetname_ = new ::std::string;
  }
  assetname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetAssetResponse_InstallAsset::mutable_assetname() {
  set_has_assetname();
  if (assetname_ == &::google::protobuf::internal::kEmptyString) {
    assetname_ = new ::std::string;
  }
  return assetname_;
}
inline ::std::string* GetAssetResponse_InstallAsset::release_assetname() {
  clear_has_assetname();
  if (assetname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = assetname_;
    assetname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string assetType = 4;
inline bool GetAssetResponse_InstallAsset::has_assettype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetAssetResponse_InstallAsset::set_has_assettype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetAssetResponse_InstallAsset::clear_has_assettype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetAssetResponse_InstallAsset::clear_assettype() {
  if (assettype_ != &::google::protobuf::internal::kEmptyString) {
    assettype_->clear();
  }
  clear_has_assettype();
}
inline const ::std::string& GetAssetResponse_InstallAsset::assettype() const {
  return *assettype_;
}
inline void GetAssetResponse_InstallAsset::set_assettype(const ::std::string& value) {
  set_has_assettype();
  if (assettype_ == &::google::protobuf::internal::kEmptyString) {
    assettype_ = new ::std::string;
  }
  assettype_->assign(value);
}
inline void GetAssetResponse_InstallAsset::set_assettype(const char* value) {
  set_has_assettype();
  if (assettype_ == &::google::protobuf::internal::kEmptyString) {
    assettype_ = new ::std::string;
  }
  assettype_->assign(value);
}
inline void GetAssetResponse_InstallAsset::set_assettype(const char* value, size_t size) {
  set_has_assettype();
  if (assettype_ == &::google::protobuf::internal::kEmptyString) {
    assettype_ = new ::std::string;
  }
  assettype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetAssetResponse_InstallAsset::mutable_assettype() {
  set_has_assettype();
  if (assettype_ == &::google::protobuf::internal::kEmptyString) {
    assettype_ = new ::std::string;
  }
  return assettype_;
}
inline ::std::string* GetAssetResponse_InstallAsset::release_assettype() {
  clear_has_assettype();
  if (assettype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = assettype_;
    assettype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string assetPackage = 5;
inline bool GetAssetResponse_InstallAsset::has_assetpackage() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetAssetResponse_InstallAsset::set_has_assetpackage() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetAssetResponse_InstallAsset::clear_has_assetpackage() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetAssetResponse_InstallAsset::clear_assetpackage() {
  if (assetpackage_ != &::google::protobuf::internal::kEmptyString) {
    assetpackage_->clear();
  }
  clear_has_assetpackage();
}
inline const ::std::string& GetAssetResponse_InstallAsset::assetpackage() const {
  return *assetpackage_;
}
inline void GetAssetResponse_InstallAsset::set_assetpackage(const ::std::string& value) {
  set_has_assetpackage();
  if (assetpackage_ == &::google::protobuf::internal::kEmptyString) {
    assetpackage_ = new ::std::string;
  }
  assetpackage_->assign(value);
}
inline void GetAssetResponse_InstallAsset::set_assetpackage(const char* value) {
  set_has_assetpackage();
  if (assetpackage_ == &::google::protobuf::internal::kEmptyString) {
    assetpackage_ = new ::std::string;
  }
  assetpackage_->assign(value);
}
inline void GetAssetResponse_InstallAsset::set_assetpackage(const char* value, size_t size) {
  set_has_assetpackage();
  if (assetpackage_ == &::google::protobuf::internal::kEmptyString) {
    assetpackage_ = new ::std::string;
  }
  assetpackage_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetAssetResponse_InstallAsset::mutable_assetpackage() {
  set_has_assetpackage();
  if (assetpackage_ == &::google::protobuf::internal::kEmptyString) {
    assetpackage_ = new ::std::string;
  }
  return assetpackage_;
}
inline ::std::string* GetAssetResponse_InstallAsset::release_assetpackage() {
  clear_has_assetpackage();
  if (assetpackage_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = assetpackage_;
    assetpackage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string blobUrl = 6;
inline bool GetAssetResponse_InstallAsset::has_bloburl() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetAssetResponse_InstallAsset::set_has_bloburl() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetAssetResponse_InstallAsset::clear_has_bloburl() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetAssetResponse_InstallAsset::clear_bloburl() {
  if (bloburl_ != &::google::protobuf::internal::kEmptyString) {
    bloburl_->clear();
  }
  clear_has_bloburl();
}
inline const ::std::string& GetAssetResponse_InstallAsset::bloburl() const {
  return *bloburl_;
}
inline void GetAssetResponse_InstallAsset::set_bloburl(const ::std::string& value) {
  set_has_bloburl();
  if (bloburl_ == &::google::protobuf::internal::kEmptyString) {
    bloburl_ = new ::std::string;
  }
  bloburl_->assign(value);
}
inline void GetAssetResponse_InstallAsset::set_bloburl(const char* value) {
  set_has_bloburl();
  if (bloburl_ == &::google::protobuf::internal::kEmptyString) {
    bloburl_ = new ::std::string;
  }
  bloburl_->assign(value);
}
inline void GetAssetResponse_InstallAsset::set_bloburl(const char* value, size_t size) {
  set_has_bloburl();
  if (bloburl_ == &::google::protobuf::internal::kEmptyString) {
    bloburl_ = new ::std::string;
  }
  bloburl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetAssetResponse_InstallAsset::mutable_bloburl() {
  set_has_bloburl();
  if (bloburl_ == &::google::protobuf::internal::kEmptyString) {
    bloburl_ = new ::std::string;
  }
  return bloburl_;
}
inline ::std::string* GetAssetResponse_InstallAsset::release_bloburl() {
  clear_has_bloburl();
  if (bloburl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bloburl_;
    bloburl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string assetSignature = 7;
inline bool GetAssetResponse_InstallAsset::has_assetsignature() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GetAssetResponse_InstallAsset::set_has_assetsignature() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GetAssetResponse_InstallAsset::clear_has_assetsignature() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GetAssetResponse_InstallAsset::clear_assetsignature() {
  if (assetsignature_ != &::google::protobuf::internal::kEmptyString) {
    assetsignature_->clear();
  }
  clear_has_assetsignature();
}
inline const ::std::string& GetAssetResponse_InstallAsset::assetsignature() const {
  return *assetsignature_;
}
inline void GetAssetResponse_InstallAsset::set_assetsignature(const ::std::string& value) {
  set_has_assetsignature();
  if (assetsignature_ == &::google::protobuf::internal::kEmptyString) {
    assetsignature_ = new ::std::string;
  }
  assetsignature_->assign(value);
}
inline void GetAssetResponse_InstallAsset::set_assetsignature(const char* value) {
  set_has_assetsignature();
  if (assetsignature_ == &::google::protobuf::internal::kEmptyString) {
    assetsignature_ = new ::std::string;
  }
  assetsignature_->assign(value);
}
inline void GetAssetResponse_InstallAsset::set_assetsignature(const char* value, size_t size) {
  set_has_assetsignature();
  if (assetsignature_ == &::google::protobuf::internal::kEmptyString) {
    assetsignature_ = new ::std::string;
  }
  assetsignature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetAssetResponse_InstallAsset::mutable_assetsignature() {
  set_has_assetsignature();
  if (assetsignature_ == &::google::protobuf::internal::kEmptyString) {
    assetsignature_ = new ::std::string;
  }
  return assetsignature_;
}
inline ::std::string* GetAssetResponse_InstallAsset::release_assetsignature() {
  clear_has_assetsignature();
  if (assetsignature_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = assetsignature_;
    assetsignature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint64 assetSize = 8;
inline bool GetAssetResponse_InstallAsset::has_assetsize() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GetAssetResponse_InstallAsset::set_has_assetsize() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GetAssetResponse_InstallAsset::clear_has_assetsize() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GetAssetResponse_InstallAsset::clear_assetsize() {
  assetsize_ = GOOGLE_ULONGLONG(0);
  clear_has_assetsize();
}
inline ::google::protobuf::uint64 GetAssetResponse_InstallAsset::assetsize() const {
  return assetsize_;
}
inline void GetAssetResponse_InstallAsset::set_assetsize(::google::protobuf::uint64 value) {
  set_has_assetsize();
  assetsize_ = value;
}

// optional uint64 refundTimeout = 9;
inline bool GetAssetResponse_InstallAsset::has_refundtimeout() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GetAssetResponse_InstallAsset::set_has_refundtimeout() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GetAssetResponse_InstallAsset::clear_has_refundtimeout() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GetAssetResponse_InstallAsset::clear_refundtimeout() {
  refundtimeout_ = GOOGLE_ULONGLONG(0);
  clear_has_refundtimeout();
}
inline ::google::protobuf::uint64 GetAssetResponse_InstallAsset::refundtimeout() const {
  return refundtimeout_;
}
inline void GetAssetResponse_InstallAsset::set_refundtimeout(::google::protobuf::uint64 value) {
  set_has_refundtimeout();
  refundtimeout_ = value;
}

// optional bool forwardLocked = 10;
inline bool GetAssetResponse_InstallAsset::has_forwardlocked() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GetAssetResponse_InstallAsset::set_has_forwardlocked() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GetAssetResponse_InstallAsset::clear_has_forwardlocked() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GetAssetResponse_InstallAsset::clear_forwardlocked() {
  forwardlocked_ = false;
  clear_has_forwardlocked();
}
inline bool GetAssetResponse_InstallAsset::forwardlocked() const {
  return forwardlocked_;
}
inline void GetAssetResponse_InstallAsset::set_forwardlocked(bool value) {
  set_has_forwardlocked();
  forwardlocked_ = value;
}

// optional bool secured = 11;
inline bool GetAssetResponse_InstallAsset::has_secured() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GetAssetResponse_InstallAsset::set_has_secured() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GetAssetResponse_InstallAsset::clear_has_secured() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GetAssetResponse_InstallAsset::clear_secured() {
  secured_ = false;
  clear_has_secured();
}
inline bool GetAssetResponse_InstallAsset::secured() const {
  return secured_;
}
inline void GetAssetResponse_InstallAsset::set_secured(bool value) {
  set_has_secured();
  secured_ = value;
}

// optional int32 versionCode = 12;
inline bool GetAssetResponse_InstallAsset::has_versioncode() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GetAssetResponse_InstallAsset::set_has_versioncode() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GetAssetResponse_InstallAsset::clear_has_versioncode() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GetAssetResponse_InstallAsset::clear_versioncode() {
  versioncode_ = 0;
  clear_has_versioncode();
}
inline ::google::protobuf::int32 GetAssetResponse_InstallAsset::versioncode() const {
  return versioncode_;
}
inline void GetAssetResponse_InstallAsset::set_versioncode(::google::protobuf::int32 value) {
  set_has_versioncode();
  versioncode_ = value;
}

// optional string downloadAuthCookieName = 13;
inline bool GetAssetResponse_InstallAsset::has_downloadauthcookiename() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GetAssetResponse_InstallAsset::set_has_downloadauthcookiename() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GetAssetResponse_InstallAsset::clear_has_downloadauthcookiename() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GetAssetResponse_InstallAsset::clear_downloadauthcookiename() {
  if (downloadauthcookiename_ != &::google::protobuf::internal::kEmptyString) {
    downloadauthcookiename_->clear();
  }
  clear_has_downloadauthcookiename();
}
inline const ::std::string& GetAssetResponse_InstallAsset::downloadauthcookiename() const {
  return *downloadauthcookiename_;
}
inline void GetAssetResponse_InstallAsset::set_downloadauthcookiename(const ::std::string& value) {
  set_has_downloadauthcookiename();
  if (downloadauthcookiename_ == &::google::protobuf::internal::kEmptyString) {
    downloadauthcookiename_ = new ::std::string;
  }
  downloadauthcookiename_->assign(value);
}
inline void GetAssetResponse_InstallAsset::set_downloadauthcookiename(const char* value) {
  set_has_downloadauthcookiename();
  if (downloadauthcookiename_ == &::google::protobuf::internal::kEmptyString) {
    downloadauthcookiename_ = new ::std::string;
  }
  downloadauthcookiename_->assign(value);
}
inline void GetAssetResponse_InstallAsset::set_downloadauthcookiename(const char* value, size_t size) {
  set_has_downloadauthcookiename();
  if (downloadauthcookiename_ == &::google::protobuf::internal::kEmptyString) {
    downloadauthcookiename_ = new ::std::string;
  }
  downloadauthcookiename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetAssetResponse_InstallAsset::mutable_downloadauthcookiename() {
  set_has_downloadauthcookiename();
  if (downloadauthcookiename_ == &::google::protobuf::internal::kEmptyString) {
    downloadauthcookiename_ = new ::std::string;
  }
  return downloadauthcookiename_;
}
inline ::std::string* GetAssetResponse_InstallAsset::release_downloadauthcookiename() {
  clear_has_downloadauthcookiename();
  if (downloadauthcookiename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = downloadauthcookiename_;
    downloadauthcookiename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string downloadAuthCookieValue = 14;
inline bool GetAssetResponse_InstallAsset::has_downloadauthcookievalue() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GetAssetResponse_InstallAsset::set_has_downloadauthcookievalue() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GetAssetResponse_InstallAsset::clear_has_downloadauthcookievalue() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GetAssetResponse_InstallAsset::clear_downloadauthcookievalue() {
  if (downloadauthcookievalue_ != &::google::protobuf::internal::kEmptyString) {
    downloadauthcookievalue_->clear();
  }
  clear_has_downloadauthcookievalue();
}
inline const ::std::string& GetAssetResponse_InstallAsset::downloadauthcookievalue() const {
  return *downloadauthcookievalue_;
}
inline void GetAssetResponse_InstallAsset::set_downloadauthcookievalue(const ::std::string& value) {
  set_has_downloadauthcookievalue();
  if (downloadauthcookievalue_ == &::google::protobuf::internal::kEmptyString) {
    downloadauthcookievalue_ = new ::std::string;
  }
  downloadauthcookievalue_->assign(value);
}
inline void GetAssetResponse_InstallAsset::set_downloadauthcookievalue(const char* value) {
  set_has_downloadauthcookievalue();
  if (downloadauthcookievalue_ == &::google::protobuf::internal::kEmptyString) {
    downloadauthcookievalue_ = new ::std::string;
  }
  downloadauthcookievalue_->assign(value);
}
inline void GetAssetResponse_InstallAsset::set_downloadauthcookievalue(const char* value, size_t size) {
  set_has_downloadauthcookievalue();
  if (downloadauthcookievalue_ == &::google::protobuf::internal::kEmptyString) {
    downloadauthcookievalue_ = new ::std::string;
  }
  downloadauthcookievalue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetAssetResponse_InstallAsset::mutable_downloadauthcookievalue() {
  set_has_downloadauthcookievalue();
  if (downloadauthcookievalue_ == &::google::protobuf::internal::kEmptyString) {
    downloadauthcookievalue_ = new ::std::string;
  }
  return downloadauthcookievalue_;
}
inline ::std::string* GetAssetResponse_InstallAsset::release_downloadauthcookievalue() {
  clear_has_downloadauthcookievalue();
  if (downloadauthcookievalue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = downloadauthcookievalue_;
    downloadauthcookievalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetAssetResponse

// repeated group InstallAsset = 1 {
inline int GetAssetResponse::installasset_size() const {
  return installasset_.size();
}
inline void GetAssetResponse::clear_installasset() {
  installasset_.Clear();
}
inline const ::GetAssetResponse_InstallAsset& GetAssetResponse::installasset(int index) const {
  return installasset_.Get(index);
}
inline ::GetAssetResponse_InstallAsset* GetAssetResponse::mutable_installasset(int index) {
  return installasset_.Mutable(index);
}
inline ::GetAssetResponse_InstallAsset* GetAssetResponse::add_installasset() {
  return installasset_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::GetAssetResponse_InstallAsset >&
GetAssetResponse::installasset() const {
  return installasset_;
}
inline ::google::protobuf::RepeatedPtrField< ::GetAssetResponse_InstallAsset >*
GetAssetResponse::mutable_installasset() {
  return &installasset_;
}

// -------------------------------------------------------------------

// Request_RequestGroup

// optional .AppsRequest appsRequest = 4;
inline bool Request_RequestGroup::has_appsrequest() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request_RequestGroup::set_has_appsrequest() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request_RequestGroup::clear_has_appsrequest() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request_RequestGroup::clear_appsrequest() {
  if (appsrequest_ != NULL) appsrequest_->::AppsRequest::Clear();
  clear_has_appsrequest();
}
inline const ::AppsRequest& Request_RequestGroup::appsrequest() const {
  return appsrequest_ != NULL ? *appsrequest_ : *default_instance_->appsrequest_;
}
inline ::AppsRequest* Request_RequestGroup::mutable_appsrequest() {
  set_has_appsrequest();
  if (appsrequest_ == NULL) appsrequest_ = new ::AppsRequest;
  return appsrequest_;
}
inline ::AppsRequest* Request_RequestGroup::release_appsrequest() {
  clear_has_appsrequest();
  ::AppsRequest* temp = appsrequest_;
  appsrequest_ = NULL;
  return temp;
}

// optional .CommentsRequest commentsRequest = 5;
inline bool Request_RequestGroup::has_commentsrequest() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request_RequestGroup::set_has_commentsrequest() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request_RequestGroup::clear_has_commentsrequest() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request_RequestGroup::clear_commentsrequest() {
  if (commentsrequest_ != NULL) commentsrequest_->::CommentsRequest::Clear();
  clear_has_commentsrequest();
}
inline const ::CommentsRequest& Request_RequestGroup::commentsrequest() const {
  return commentsrequest_ != NULL ? *commentsrequest_ : *default_instance_->commentsrequest_;
}
inline ::CommentsRequest* Request_RequestGroup::mutable_commentsrequest() {
  set_has_commentsrequest();
  if (commentsrequest_ == NULL) commentsrequest_ = new ::CommentsRequest;
  return commentsrequest_;
}
inline ::CommentsRequest* Request_RequestGroup::release_commentsrequest() {
  clear_has_commentsrequest();
  ::CommentsRequest* temp = commentsrequest_;
  commentsrequest_ = NULL;
  return temp;
}

// optional .GetAssetRequest getAssetRequest = 10;
inline bool Request_RequestGroup::has_getassetrequest() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request_RequestGroup::set_has_getassetrequest() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request_RequestGroup::clear_has_getassetrequest() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request_RequestGroup::clear_getassetrequest() {
  if (getassetrequest_ != NULL) getassetrequest_->::GetAssetRequest::Clear();
  clear_has_getassetrequest();
}
inline const ::GetAssetRequest& Request_RequestGroup::getassetrequest() const {
  return getassetrequest_ != NULL ? *getassetrequest_ : *default_instance_->getassetrequest_;
}
inline ::GetAssetRequest* Request_RequestGroup::mutable_getassetrequest() {
  set_has_getassetrequest();
  if (getassetrequest_ == NULL) getassetrequest_ = new ::GetAssetRequest;
  return getassetrequest_;
}
inline ::GetAssetRequest* Request_RequestGroup::release_getassetrequest() {
  clear_has_getassetrequest();
  ::GetAssetRequest* temp = getassetrequest_;
  getassetrequest_ = NULL;
  return temp;
}

// optional .GetImageRequest imageRequest = 11;
inline bool Request_RequestGroup::has_imagerequest() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Request_RequestGroup::set_has_imagerequest() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Request_RequestGroup::clear_has_imagerequest() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Request_RequestGroup::clear_imagerequest() {
  if (imagerequest_ != NULL) imagerequest_->::GetImageRequest::Clear();
  clear_has_imagerequest();
}
inline const ::GetImageRequest& Request_RequestGroup::imagerequest() const {
  return imagerequest_ != NULL ? *imagerequest_ : *default_instance_->imagerequest_;
}
inline ::GetImageRequest* Request_RequestGroup::mutable_imagerequest() {
  set_has_imagerequest();
  if (imagerequest_ == NULL) imagerequest_ = new ::GetImageRequest;
  return imagerequest_;
}
inline ::GetImageRequest* Request_RequestGroup::release_imagerequest() {
  clear_has_imagerequest();
  ::GetImageRequest* temp = imagerequest_;
  imagerequest_ = NULL;
  return temp;
}

// optional .SubCategoriesRequest subCategoriesRequest = 14;
inline bool Request_RequestGroup::has_subcategoriesrequest() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Request_RequestGroup::set_has_subcategoriesrequest() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Request_RequestGroup::clear_has_subcategoriesrequest() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Request_RequestGroup::clear_subcategoriesrequest() {
  if (subcategoriesrequest_ != NULL) subcategoriesrequest_->::SubCategoriesRequest::Clear();
  clear_has_subcategoriesrequest();
}
inline const ::SubCategoriesRequest& Request_RequestGroup::subcategoriesrequest() const {
  return subcategoriesrequest_ != NULL ? *subcategoriesrequest_ : *default_instance_->subcategoriesrequest_;
}
inline ::SubCategoriesRequest* Request_RequestGroup::mutable_subcategoriesrequest() {
  set_has_subcategoriesrequest();
  if (subcategoriesrequest_ == NULL) subcategoriesrequest_ = new ::SubCategoriesRequest;
  return subcategoriesrequest_;
}
inline ::SubCategoriesRequest* Request_RequestGroup::release_subcategoriesrequest() {
  clear_has_subcategoriesrequest();
  ::SubCategoriesRequest* temp = subcategoriesrequest_;
  subcategoriesrequest_ = NULL;
  return temp;
}

// optional .CategoriesRequest categoriesRequest = 21;
inline bool Request_RequestGroup::has_categoriesrequest() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Request_RequestGroup::set_has_categoriesrequest() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Request_RequestGroup::clear_has_categoriesrequest() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Request_RequestGroup::clear_categoriesrequest() {
  if (categoriesrequest_ != NULL) categoriesrequest_->::CategoriesRequest::Clear();
  clear_has_categoriesrequest();
}
inline const ::CategoriesRequest& Request_RequestGroup::categoriesrequest() const {
  return categoriesrequest_ != NULL ? *categoriesrequest_ : *default_instance_->categoriesrequest_;
}
inline ::CategoriesRequest* Request_RequestGroup::mutable_categoriesrequest() {
  set_has_categoriesrequest();
  if (categoriesrequest_ == NULL) categoriesrequest_ = new ::CategoriesRequest;
  return categoriesrequest_;
}
inline ::CategoriesRequest* Request_RequestGroup::release_categoriesrequest() {
  clear_has_categoriesrequest();
  ::CategoriesRequest* temp = categoriesrequest_;
  categoriesrequest_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Request

// optional .RequestContext context = 1;
inline bool Request::has_context() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request::set_has_context() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request::clear_has_context() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request::clear_context() {
  if (context_ != NULL) context_->::RequestContext::Clear();
  clear_has_context();
}
inline const ::RequestContext& Request::context() const {
  return context_ != NULL ? *context_ : *default_instance_->context_;
}
inline ::RequestContext* Request::mutable_context() {
  set_has_context();
  if (context_ == NULL) context_ = new ::RequestContext;
  return context_;
}
inline ::RequestContext* Request::release_context() {
  clear_has_context();
  ::RequestContext* temp = context_;
  context_ = NULL;
  return temp;
}

// repeated group RequestGroup = 2 {
inline int Request::requestgroup_size() const {
  return requestgroup_.size();
}
inline void Request::clear_requestgroup() {
  requestgroup_.Clear();
}
inline const ::Request_RequestGroup& Request::requestgroup(int index) const {
  return requestgroup_.Get(index);
}
inline ::Request_RequestGroup* Request::mutable_requestgroup(int index) {
  return requestgroup_.Mutable(index);
}
inline ::Request_RequestGroup* Request::add_requestgroup() {
  return requestgroup_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Request_RequestGroup >&
Request::requestgroup() const {
  return requestgroup_;
}
inline ::google::protobuf::RepeatedPtrField< ::Request_RequestGroup >*
Request::mutable_requestgroup() {
  return &requestgroup_;
}

// -------------------------------------------------------------------

// ResponseContext

// optional .ResponseContext.ResultType result = 1;
inline bool ResponseContext::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseContext::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseContext::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseContext::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::ResponseContext_ResultType ResponseContext::result() const {
  return static_cast< ::ResponseContext_ResultType >(result_);
}
inline void ResponseContext::set_result(::ResponseContext_ResultType value) {
  GOOGLE_DCHECK(::ResponseContext_ResultType_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional int32 maxAge = 2;
inline bool ResponseContext::has_maxage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseContext::set_has_maxage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseContext::clear_has_maxage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseContext::clear_maxage() {
  maxage_ = 0;
  clear_has_maxage();
}
inline ::google::protobuf::int32 ResponseContext::maxage() const {
  return maxage_;
}
inline void ResponseContext::set_maxage(::google::protobuf::int32 value) {
  set_has_maxage();
  maxage_ = value;
}

// optional string etag = 3;
inline bool ResponseContext::has_etag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseContext::set_has_etag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseContext::clear_has_etag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseContext::clear_etag() {
  if (etag_ != &::google::protobuf::internal::kEmptyString) {
    etag_->clear();
  }
  clear_has_etag();
}
inline const ::std::string& ResponseContext::etag() const {
  return *etag_;
}
inline void ResponseContext::set_etag(const ::std::string& value) {
  set_has_etag();
  if (etag_ == &::google::protobuf::internal::kEmptyString) {
    etag_ = new ::std::string;
  }
  etag_->assign(value);
}
inline void ResponseContext::set_etag(const char* value) {
  set_has_etag();
  if (etag_ == &::google::protobuf::internal::kEmptyString) {
    etag_ = new ::std::string;
  }
  etag_->assign(value);
}
inline void ResponseContext::set_etag(const char* value, size_t size) {
  set_has_etag();
  if (etag_ == &::google::protobuf::internal::kEmptyString) {
    etag_ = new ::std::string;
  }
  etag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseContext::mutable_etag() {
  set_has_etag();
  if (etag_ == &::google::protobuf::internal::kEmptyString) {
    etag_ = new ::std::string;
  }
  return etag_;
}
inline ::std::string* ResponseContext::release_etag() {
  clear_has_etag();
  if (etag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = etag_;
    etag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 serverVersion = 4;
inline bool ResponseContext::has_serverversion() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResponseContext::set_has_serverversion() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResponseContext::clear_has_serverversion() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResponseContext::clear_serverversion() {
  serverversion_ = 0;
  clear_has_serverversion();
}
inline ::google::protobuf::int32 ResponseContext::serverversion() const {
  return serverversion_;
}
inline void ResponseContext::set_serverversion(::google::protobuf::int32 value) {
  set_has_serverversion();
  serverversion_ = value;
}

// -------------------------------------------------------------------

// Response_ResponseGroup

// optional .ResponseContext context = 2;
inline bool Response_ResponseGroup::has_context() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_ResponseGroup::set_has_context() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_ResponseGroup::clear_has_context() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_ResponseGroup::clear_context() {
  if (context_ != NULL) context_->::ResponseContext::Clear();
  clear_has_context();
}
inline const ::ResponseContext& Response_ResponseGroup::context() const {
  return context_ != NULL ? *context_ : *default_instance_->context_;
}
inline ::ResponseContext* Response_ResponseGroup::mutable_context() {
  set_has_context();
  if (context_ == NULL) context_ = new ::ResponseContext;
  return context_;
}
inline ::ResponseContext* Response_ResponseGroup::release_context() {
  clear_has_context();
  ::ResponseContext* temp = context_;
  context_ = NULL;
  return temp;
}

// optional .AppsResponse appsResponse = 3;
inline bool Response_ResponseGroup::has_appsresponse() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response_ResponseGroup::set_has_appsresponse() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response_ResponseGroup::clear_has_appsresponse() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response_ResponseGroup::clear_appsresponse() {
  if (appsresponse_ != NULL) appsresponse_->::AppsResponse::Clear();
  clear_has_appsresponse();
}
inline const ::AppsResponse& Response_ResponseGroup::appsresponse() const {
  return appsresponse_ != NULL ? *appsresponse_ : *default_instance_->appsresponse_;
}
inline ::AppsResponse* Response_ResponseGroup::mutable_appsresponse() {
  set_has_appsresponse();
  if (appsresponse_ == NULL) appsresponse_ = new ::AppsResponse;
  return appsresponse_;
}
inline ::AppsResponse* Response_ResponseGroup::release_appsresponse() {
  clear_has_appsresponse();
  ::AppsResponse* temp = appsresponse_;
  appsresponse_ = NULL;
  return temp;
}

// optional .CommentsResponse commentsResponse = 4;
inline bool Response_ResponseGroup::has_commentsresponse() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Response_ResponseGroup::set_has_commentsresponse() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Response_ResponseGroup::clear_has_commentsresponse() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Response_ResponseGroup::clear_commentsresponse() {
  if (commentsresponse_ != NULL) commentsresponse_->::CommentsResponse::Clear();
  clear_has_commentsresponse();
}
inline const ::CommentsResponse& Response_ResponseGroup::commentsresponse() const {
  return commentsresponse_ != NULL ? *commentsresponse_ : *default_instance_->commentsresponse_;
}
inline ::CommentsResponse* Response_ResponseGroup::mutable_commentsresponse() {
  set_has_commentsresponse();
  if (commentsresponse_ == NULL) commentsresponse_ = new ::CommentsResponse;
  return commentsresponse_;
}
inline ::CommentsResponse* Response_ResponseGroup::release_commentsresponse() {
  clear_has_commentsresponse();
  ::CommentsResponse* temp = commentsresponse_;
  commentsresponse_ = NULL;
  return temp;
}

// optional .GetAssetResponse getAssetResponse = 9;
inline bool Response_ResponseGroup::has_getassetresponse() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Response_ResponseGroup::set_has_getassetresponse() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Response_ResponseGroup::clear_has_getassetresponse() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Response_ResponseGroup::clear_getassetresponse() {
  if (getassetresponse_ != NULL) getassetresponse_->::GetAssetResponse::Clear();
  clear_has_getassetresponse();
}
inline const ::GetAssetResponse& Response_ResponseGroup::getassetresponse() const {
  return getassetresponse_ != NULL ? *getassetresponse_ : *default_instance_->getassetresponse_;
}
inline ::GetAssetResponse* Response_ResponseGroup::mutable_getassetresponse() {
  set_has_getassetresponse();
  if (getassetresponse_ == NULL) getassetresponse_ = new ::GetAssetResponse;
  return getassetresponse_;
}
inline ::GetAssetResponse* Response_ResponseGroup::release_getassetresponse() {
  clear_has_getassetresponse();
  ::GetAssetResponse* temp = getassetresponse_;
  getassetresponse_ = NULL;
  return temp;
}

// optional .GetImageResponse imageResponse = 10;
inline bool Response_ResponseGroup::has_imageresponse() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Response_ResponseGroup::set_has_imageresponse() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Response_ResponseGroup::clear_has_imageresponse() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Response_ResponseGroup::clear_imageresponse() {
  if (imageresponse_ != NULL) imageresponse_->::GetImageResponse::Clear();
  clear_has_imageresponse();
}
inline const ::GetImageResponse& Response_ResponseGroup::imageresponse() const {
  return imageresponse_ != NULL ? *imageresponse_ : *default_instance_->imageresponse_;
}
inline ::GetImageResponse* Response_ResponseGroup::mutable_imageresponse() {
  set_has_imageresponse();
  if (imageresponse_ == NULL) imageresponse_ = new ::GetImageResponse;
  return imageresponse_;
}
inline ::GetImageResponse* Response_ResponseGroup::release_imageresponse() {
  clear_has_imageresponse();
  ::GetImageResponse* temp = imageresponse_;
  imageresponse_ = NULL;
  return temp;
}

// optional .CategoriesResponse categoriesResponse = 20;
inline bool Response_ResponseGroup::has_categoriesresponse() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Response_ResponseGroup::set_has_categoriesresponse() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Response_ResponseGroup::clear_has_categoriesresponse() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Response_ResponseGroup::clear_categoriesresponse() {
  if (categoriesresponse_ != NULL) categoriesresponse_->::CategoriesResponse::Clear();
  clear_has_categoriesresponse();
}
inline const ::CategoriesResponse& Response_ResponseGroup::categoriesresponse() const {
  return categoriesresponse_ != NULL ? *categoriesresponse_ : *default_instance_->categoriesresponse_;
}
inline ::CategoriesResponse* Response_ResponseGroup::mutable_categoriesresponse() {
  set_has_categoriesresponse();
  if (categoriesresponse_ == NULL) categoriesresponse_ = new ::CategoriesResponse;
  return categoriesresponse_;
}
inline ::CategoriesResponse* Response_ResponseGroup::release_categoriesresponse() {
  clear_has_categoriesresponse();
  ::CategoriesResponse* temp = categoriesresponse_;
  categoriesresponse_ = NULL;
  return temp;
}

// optional .SubCategoriesResponse subCategoriesResponse = 13;
inline bool Response_ResponseGroup::has_subcategoriesresponse() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Response_ResponseGroup::set_has_subcategoriesresponse() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Response_ResponseGroup::clear_has_subcategoriesresponse() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Response_ResponseGroup::clear_subcategoriesresponse() {
  if (subcategoriesresponse_ != NULL) subcategoriesresponse_->::SubCategoriesResponse::Clear();
  clear_has_subcategoriesresponse();
}
inline const ::SubCategoriesResponse& Response_ResponseGroup::subcategoriesresponse() const {
  return subcategoriesresponse_ != NULL ? *subcategoriesresponse_ : *default_instance_->subcategoriesresponse_;
}
inline ::SubCategoriesResponse* Response_ResponseGroup::mutable_subcategoriesresponse() {
  set_has_subcategoriesresponse();
  if (subcategoriesresponse_ == NULL) subcategoriesresponse_ = new ::SubCategoriesResponse;
  return subcategoriesresponse_;
}
inline ::SubCategoriesResponse* Response_ResponseGroup::release_subcategoriesresponse() {
  clear_has_subcategoriesresponse();
  ::SubCategoriesResponse* temp = subcategoriesresponse_;
  subcategoriesresponse_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Response

// repeated group ResponseGroup = 1 {
inline int Response::responsegroup_size() const {
  return responsegroup_.size();
}
inline void Response::clear_responsegroup() {
  responsegroup_.Clear();
}
inline const ::Response_ResponseGroup& Response::responsegroup(int index) const {
  return responsegroup_.Get(index);
}
inline ::Response_ResponseGroup* Response::mutable_responsegroup(int index) {
  return responsegroup_.Mutable(index);
}
inline ::Response_ResponseGroup* Response::add_responsegroup() {
  return responsegroup_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Response_ResponseGroup >&
Response::responsegroup() const {
  return responsegroup_;
}
inline ::google::protobuf::RepeatedPtrField< ::Response_ResponseGroup >*
Response::mutable_responsegroup() {
  return &responsegroup_;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AppsRequest_OrderType>() {
  return ::AppsRequest_OrderType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AppsRequest_ViewType>() {
  return ::AppsRequest_ViewType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::GetImageRequest_AppImageUsage>() {
  return ::GetImageRequest_AppImageUsage_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ResponseContext_ResultType>() {
  return ::ResponseContext_ResultType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< AppType>() {
  return AppType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_market_2eproto__INCLUDED
